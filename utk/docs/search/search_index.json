{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Uni{corn|form} Tool Kit The UTK tool kit aims at providing executables to generate and analyze point sets in unit domains [0,1)^s [0,1)^s . It is originally meant to help researchers developing sampling patterns in a numerical integration using Monte Carlo estimators. More precisely, it was developed with the precise question of optimizing image synthesis via Path tracing algorithms. UTK is a C++ library that implements a large variety of samplers and tools to analyze and compare them (discrepancy evaluation, spectral analysis, numerical integration tests\u2026). License The core of the library is available under the BSD license. For some samplers, the library is just a wrapper on some codes with specific license (see the samplers page for details). Clone and Build UTK is hosted on a git repository. To install it, the first step is to clone the repository on your computer. This can be done using the following command line: git clone https://github.com/utk-team/utk.git The code can be build on a Linux or a Mac environment. The Windows build is not yet supported. To build it, one can use the following commands, assuming the current working directory is the cloned utk repository. mkdir build cd build cmake .. make External libraries The UTK repository provides the files for two external libraries: CImg (for image processing) dCpp (for automatic differentiation). Some specific tools may require additional dependencies: CGAL (to generate analytical shapes arrangements) FFTW3 (to compute Fourier spectra) Finally, it also strongly relies on the Gnuplot framework to generate graphs. Note that none of those libraries are mandatory. When building the UTK framework, the external dependancies can be either activated or deactivated. Each tool of this framework is compiled independently. If a dependency is marked as unrequired, all the tools that do not require this dependency are still compiled. Originally, only CImg and dCpp are activated, since they are very light libraries and are provided with the framework. To activate or deactivate a library, one can either edit the file utk/CMakeLists.txt to set to true/false the variables [LIBRARY]_ON . Alternatively, you can pass some options at the cmake step (or use ccmake or cmake-gui ), e.g.: cmake .. -DUSE_FFTW=true Authors The UTK library was developed mainly by David Coeurjolly david.coeurjolly@liris.cnrs.fr H\u00e9l\u00e8ne Perrier helene.perrier@liris.cnrs.fr But was also contributed to by Victor Ostromoukhov victor.ostromoukhov@liris.cnrs.fr Adrien Pilleboue Jean David Genevaux If you want to refer to UTK in your publications, please use the following bibtex entry: @Misc{UTK, title = {Uni(corn|form) tool kit}, note = {url{https://utk-team.github.io/utk/}} } Contributing UTK is an open-source, community driven, project. If you want to help us (typos, documentations issues, new samplers, new tools\u2026), feel free to create a Pull-Request on the Github project.","title":"Home"},{"location":"#unicornform-tool-kit","text":"The UTK tool kit aims at providing executables to generate and analyze point sets in unit domains [0,1)^s [0,1)^s . It is originally meant to help researchers developing sampling patterns in a numerical integration using Monte Carlo estimators. More precisely, it was developed with the precise question of optimizing image synthesis via Path tracing algorithms. UTK is a C++ library that implements a large variety of samplers and tools to analyze and compare them (discrepancy evaluation, spectral analysis, numerical integration tests\u2026).","title":"Uni{corn|form} Tool Kit"},{"location":"#license","text":"The core of the library is available under the BSD license. For some samplers, the library is just a wrapper on some codes with specific license (see the samplers page for details).","title":"License"},{"location":"#clone-and-build","text":"UTK is hosted on a git repository. To install it, the first step is to clone the repository on your computer. This can be done using the following command line: git clone https://github.com/utk-team/utk.git The code can be build on a Linux or a Mac environment. The Windows build is not yet supported. To build it, one can use the following commands, assuming the current working directory is the cloned utk repository. mkdir build cd build cmake .. make","title":"Clone and Build"},{"location":"#external-libraries","text":"The UTK repository provides the files for two external libraries: CImg (for image processing) dCpp (for automatic differentiation). Some specific tools may require additional dependencies: CGAL (to generate analytical shapes arrangements) FFTW3 (to compute Fourier spectra) Finally, it also strongly relies on the Gnuplot framework to generate graphs. Note that none of those libraries are mandatory. When building the UTK framework, the external dependancies can be either activated or deactivated. Each tool of this framework is compiled independently. If a dependency is marked as unrequired, all the tools that do not require this dependency are still compiled. Originally, only CImg and dCpp are activated, since they are very light libraries and are provided with the framework. To activate or deactivate a library, one can either edit the file utk/CMakeLists.txt to set to true/false the variables [LIBRARY]_ON . Alternatively, you can pass some options at the cmake step (or use ccmake or cmake-gui ), e.g.: cmake .. -DUSE_FFTW=true","title":"External libraries"},{"location":"#authors","text":"The UTK library was developed mainly by David Coeurjolly david.coeurjolly@liris.cnrs.fr H\u00e9l\u00e8ne Perrier helene.perrier@liris.cnrs.fr But was also contributed to by Victor Ostromoukhov victor.ostromoukhov@liris.cnrs.fr Adrien Pilleboue Jean David Genevaux If you want to refer to UTK in your publications, please use the following bibtex entry: @Misc{UTK, title = {Uni(corn|form) tool kit}, note = {url{https://utk-team.github.io/utk/}} }","title":"Authors"},{"location":"#contributing","text":"UTK is an open-source, community driven, project. If you want to help us (typos, documentations issues, new samplers, new tools\u2026), feel free to create a Pull-Request on the Github project.","title":"Contributing"},{"location":"Changelog/","text":"2021-Aug: Adding code and documentation for Diaphony (Mayur Patel, mayur.patel.rogers@gmail.com) 2020-Nov: Cleanup in the Generalized L2 Discrepancy code 2020-Jan: Bugfix FFTW_INCLUDES headers 2020-Jan: More Jittered samplers 2019-Nov: Adding Matt Pharr\u2019s variant of PMJ02 (faster) 2019-Sep: Adding Lloyd\u2019s relaxation sampler in 3D (toroidal and non-toroidal) domains using Geogram 2019-Aug: Global refactoring of the website 2019-Jun: Adding Progressive MultiJittered Samplers (PM,PMJ, PMJ02)","title":"Changelog"},{"location":"basicclasses/","text":"Doxygen I/O Formats","title":"Basicclasses"},{"location":"discrepancy_bounds_star_disc/","text":"Fast Bounds on Linf Discrepancy Files src/discrepancy/BoundariesStarDiscrepancy.hpp src/bin/discrepancy/BoundariesStarDiscrepancy_2dd.cpp Description Code from [Thi01] . This tool approximates upper and lower boundaries on the Linf discrepancy. As those approximations can be computed faster than the true value, it allows to approximate the Linf discrepancy of higher dimensional point sets. Can be used in higher dimensions. Execution Parameters: [HELP] -h [string] Displays this help message -i [string] The input pointsets -o [string] The output discrepancies -s [uint] The number of samples to read (if computing from a sequence) --silent Silent mode --brute Output brute values instead of computing the statistics --epsilon [double] Sets the epsilon to use for the boundary computation. Must be in [0, 1] --epsilon-auto Automatically sets the epsilon as log(N)^(d-1)/N To evaluate the discrepancy of an input 2D point set, one can use the following client line command: ./bin/discrepancy/BoundariesStarDiscrepancy_fromfile_2dd --epsilon 0.01 -i toto.dat Or one can use the following C++ code: BoundariesStarDiscrepancy discrepancy_test ; DiscrepancyStatistics statsBoundMin ; DiscrepancyStatistics statsBoundMax ; Pointset < D , double , Point > pts ; //We assume pts is filled statsBoundMin . nbpts = pts . size (); //Can be done several times if we need to average over //several stochastic pointsets std :: array discrepancy ; disc . compute < D , double , Point > ( pts , param_epsilon , discrepancy ) statsBoundMin . addValue ( discrepancy [ 0 ]); statsBoundMax . addValue ( discrepancy [ 1 ]); statsBoundMin . computeStatistics (); std :: cout << statsBoundMin << std :: endl ; statsBoundMax . computeStatistics (); std :: cout << statsBoundMax << std :: endl ; Results Illustration graph with the Whitenoise and the Halton sampler. Stochastic sampler ./bin/discrepancy/BoundariesStarDiscrepancy_fromfile_2dd --epsilon 0.01 -i stratified_256.dat #Nbpts Epsilon MinBoundMin MaxBoundMax Iter 256 0.01 0.027214 0.0516146 10 \u2026 ./bin/discrepancy/BoundariesStarDiscrepancy_fromfile_2dd --epsilon 0.01 -i stratified_1024.dat #Nbpts Epsilon MinBoundMin MaxBoundMax Iter 1024 0.01 0.0107846 0.0238923 10 \u2026 ./bin/discrepancy/BoundariesStarDiscrepancy_fromfile_2dd --epsilon 0.01 -i stratified_4096.dat #Nbpts Epsilon MinBoundMin MaxBoundMax Iter 4096 0.01 0.00359415 0.0142907 10 \u2026 Deterministic sampler ./bin/discrepancy/BoundariesStarDiscrepancy_fromfile_2dd --epsilon 0.01 -i sobol_1024.dat #Nbpts Epsilon MinBoundMin MaxBoundMax Iter 1024 0.01 0.00356102 0.0133135 1 ./bin/discrepancy/BoundariesStarDiscrepancy_fromfile_2dd --epsilon 0.01 -i sobol_4096.dat #Nbpts Epsilon MinBoundMin MaxBoundMax Iter 4096 0.01 0.00103152 0.0110033 1 Changing the Epsilon ./bin/discrepancy/BoundariesStarDiscrepancy_fromfile_2dd --epsilon 0.1 -i sobol_4096.dat #Nbpts Epsilon MinBoundMin MaxBoundMax Iter 4096 0.1 0.000883877 0.100749 1 ./bin/discrepancy/BoundariesStarDiscrepancy_fromfile_2dd --epsilon 0.005 -i sobol_4096.dat #Nbpts Epsilon MinBoundMin MaxBoundMax Iter 4096 0.005 0.00124788 0.0059875 1","title":"Fast bounds on the Star Discrepancy"},{"location":"discrepancy_bounds_star_disc/#fast-bounds-on-linf-discrepancy","text":"","title":"Fast Bounds on Linf Discrepancy"},{"location":"discrepancy_bounds_star_disc/#files","text":"src/discrepancy/BoundariesStarDiscrepancy.hpp src/bin/discrepancy/BoundariesStarDiscrepancy_2dd.cpp","title":"Files"},{"location":"discrepancy_bounds_star_disc/#description","text":"Code from [Thi01] . This tool approximates upper and lower boundaries on the Linf discrepancy. As those approximations can be computed faster than the true value, it allows to approximate the Linf discrepancy of higher dimensional point sets. Can be used in higher dimensions.","title":"Description"},{"location":"discrepancy_bounds_star_disc/#execution","text":"Parameters: [HELP] -h [string] Displays this help message -i [string] The input pointsets -o [string] The output discrepancies -s [uint] The number of samples to read (if computing from a sequence) --silent Silent mode --brute Output brute values instead of computing the statistics --epsilon [double] Sets the epsilon to use for the boundary computation. Must be in [0, 1] --epsilon-auto Automatically sets the epsilon as log(N)^(d-1)/N To evaluate the discrepancy of an input 2D point set, one can use the following client line command: ./bin/discrepancy/BoundariesStarDiscrepancy_fromfile_2dd --epsilon 0.01 -i toto.dat Or one can use the following C++ code: BoundariesStarDiscrepancy discrepancy_test ; DiscrepancyStatistics statsBoundMin ; DiscrepancyStatistics statsBoundMax ; Pointset < D , double , Point > pts ; //We assume pts is filled statsBoundMin . nbpts = pts . size (); //Can be done several times if we need to average over //several stochastic pointsets std :: array discrepancy ; disc . compute < D , double , Point > ( pts , param_epsilon , discrepancy ) statsBoundMin . addValue ( discrepancy [ 0 ]); statsBoundMax . addValue ( discrepancy [ 1 ]); statsBoundMin . computeStatistics (); std :: cout << statsBoundMin << std :: endl ; statsBoundMax . computeStatistics (); std :: cout << statsBoundMax << std :: endl ;","title":"Execution"},{"location":"discrepancy_bounds_star_disc/#results","text":"Illustration graph with the Whitenoise and the Halton sampler. Stochastic sampler ./bin/discrepancy/BoundariesStarDiscrepancy_fromfile_2dd --epsilon 0.01 -i stratified_256.dat #Nbpts Epsilon MinBoundMin MaxBoundMax Iter 256 0.01 0.027214 0.0516146 10 \u2026 ./bin/discrepancy/BoundariesStarDiscrepancy_fromfile_2dd --epsilon 0.01 -i stratified_1024.dat #Nbpts Epsilon MinBoundMin MaxBoundMax Iter 1024 0.01 0.0107846 0.0238923 10 \u2026 ./bin/discrepancy/BoundariesStarDiscrepancy_fromfile_2dd --epsilon 0.01 -i stratified_4096.dat #Nbpts Epsilon MinBoundMin MaxBoundMax Iter 4096 0.01 0.00359415 0.0142907 10 \u2026 Deterministic sampler ./bin/discrepancy/BoundariesStarDiscrepancy_fromfile_2dd --epsilon 0.01 -i sobol_1024.dat #Nbpts Epsilon MinBoundMin MaxBoundMax Iter 1024 0.01 0.00356102 0.0133135 1 ./bin/discrepancy/BoundariesStarDiscrepancy_fromfile_2dd --epsilon 0.01 -i sobol_4096.dat #Nbpts Epsilon MinBoundMin MaxBoundMax Iter 4096 0.01 0.00103152 0.0110033 1 Changing the Epsilon ./bin/discrepancy/BoundariesStarDiscrepancy_fromfile_2dd --epsilon 0.1 -i sobol_4096.dat #Nbpts Epsilon MinBoundMin MaxBoundMax Iter 4096 0.1 0.000883877 0.100749 1 ./bin/discrepancy/BoundariesStarDiscrepancy_fromfile_2dd --epsilon 0.005 -i sobol_4096.dat #Nbpts Epsilon MinBoundMin MaxBoundMax Iter 4096 0.005 0.00124788 0.0059875 1","title":"Results"},{"location":"discrepancy_centered_l2_disc/","text":"Centered L2 Discrepancy Files src/discrepancy/CenteredL2Discrepancy.hpp src/bin/discrepancy/CenteredL2Discrepancy_2dd.cpp Description This tool computes the Centered L2 discrepancy of an input pointset using the following formula from [Hic98] . License BSD, see CenteredL2Discrepancy.hpp Execution Parameters: [HELP] -h [string] Displays this help message -i [string] The input pointsets -o [string] The output discrepancies -s [uint] The number of samples to read (if computing from a sequence) --silent Silent mode --brute Output brute values instead of computing the statistics To evaluate the discrepancy of an input 2D point set, one can use the following client line command: ./bin/discrepancy/CenteredL2Discrepancy_fromfile_2dd -i toto.dat Or one can use the following C++ code: CenteredL2Discrepancy . hpp discrepancy_test ; DiscrepancyStatistics stats ; Pointset < D , double , Point > pts ; //We assume pts is filled stats . nbpts = pts . size (); //Can be done several times if we need to average over //several stochastic pointsets double discrepancy = 0 ; discrepancy_test . compute < D , double , Point > ( pts , discrepancy ) stats . addValue ( discrepancy ); stats . computeStatistics (); std :: cout << stats << std :: endl ; Results Stochastic sampler ./bin/discrepancy/CenteredL2Discrepancy_fromfile_2dd -i stratified_256.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 256 0.0100191 2.32342e-07 0.00927838 0.0108118 10 \u2026 ./bin/discrepancy/CenteredL2Discrepancy_fromfile_2dd -i stratified_1024.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 1024 0.00358071 2.12656e-08 0.00332768 0.00376758 10 \u2026 ./bin/discrepancy/CenteredL2Discrepancy_fromfile_2dd -i stratified_4096.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 4096 0.0012567 2.50781e-09 0.00120009 0.00134903 10 \u2026 Deterministic sampler ./bin/discrepancy/CenteredL2Discrepancy_fromfile_2dd -i sobol_1024.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 1024 0.00105202 0 0.00105202 0.00105202 1 ./bin/discrepancy/CenteredL2Discrepancy_fromfile_2dd -i sobol_4096.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 4096 0.000276215 0 0.000276215 0.000276215 1","title":"Centered L2 Discrepancy"},{"location":"discrepancy_centered_l2_disc/#centered-l2-discrepancy","text":"","title":"Centered L2 Discrepancy"},{"location":"discrepancy_centered_l2_disc/#files","text":"src/discrepancy/CenteredL2Discrepancy.hpp src/bin/discrepancy/CenteredL2Discrepancy_2dd.cpp","title":"Files"},{"location":"discrepancy_centered_l2_disc/#description","text":"This tool computes the Centered L2 discrepancy of an input pointset using the following formula from [Hic98] .","title":"Description"},{"location":"discrepancy_centered_l2_disc/#license","text":"BSD, see CenteredL2Discrepancy.hpp","title":"License"},{"location":"discrepancy_centered_l2_disc/#execution","text":"Parameters: [HELP] -h [string] Displays this help message -i [string] The input pointsets -o [string] The output discrepancies -s [uint] The number of samples to read (if computing from a sequence) --silent Silent mode --brute Output brute values instead of computing the statistics To evaluate the discrepancy of an input 2D point set, one can use the following client line command: ./bin/discrepancy/CenteredL2Discrepancy_fromfile_2dd -i toto.dat Or one can use the following C++ code: CenteredL2Discrepancy . hpp discrepancy_test ; DiscrepancyStatistics stats ; Pointset < D , double , Point > pts ; //We assume pts is filled stats . nbpts = pts . size (); //Can be done several times if we need to average over //several stochastic pointsets double discrepancy = 0 ; discrepancy_test . compute < D , double , Point > ( pts , discrepancy ) stats . addValue ( discrepancy ); stats . computeStatistics (); std :: cout << stats << std :: endl ;","title":"Execution"},{"location":"discrepancy_centered_l2_disc/#results","text":"Stochastic sampler ./bin/discrepancy/CenteredL2Discrepancy_fromfile_2dd -i stratified_256.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 256 0.0100191 2.32342e-07 0.00927838 0.0108118 10 \u2026 ./bin/discrepancy/CenteredL2Discrepancy_fromfile_2dd -i stratified_1024.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 1024 0.00358071 2.12656e-08 0.00332768 0.00376758 10 \u2026 ./bin/discrepancy/CenteredL2Discrepancy_fromfile_2dd -i stratified_4096.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 4096 0.0012567 2.50781e-09 0.00120009 0.00134903 10 \u2026 Deterministic sampler ./bin/discrepancy/CenteredL2Discrepancy_fromfile_2dd -i sobol_1024.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 1024 0.00105202 0 0.00105202 0.00105202 1 ./bin/discrepancy/CenteredL2Discrepancy_fromfile_2dd -i sobol_4096.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 4096 0.000276215 0 0.000276215 0.000276215 1","title":"Results"},{"location":"discrepancy_diaphony/","text":"Diaphony Files src/discrepancy/Diaphony.hpp src/bin/discrepancy/Diaphony_2dd.cpp src/bin/discrepancy/Diaphony_3dd.cpp src/bin/discrepancy/Diaphony_4dd.cpp Description Diaphony is a metric of point set uniformity closely related to discrepancy. This tool computes the diaphony in s(N^2) time, with N points in dimension s. from ZINTERHOF, P. 1976. Uber einige Absch~itzungen bei der Approximation von Funktionen mit Gleichverteilungsmethoden. Sitzungsber. Osterr. Akad. Wiss. Math.-Natur. K1. H 185, 121-132. License BSD, see Diaphony.hpp Execution Parameters: [HELP] -h [string] Displays this help message -i [string] The input pointsets -o [string] The output discrepancies -s [uint] The number of samples to read (if computing from a sequence) --silent Silent mode --brute Output brute values instead of computing the statistics To evaluate the diaphony of an input 2D point set, one can use the following client line command: ./bin/discrepancy/Diaphony_fromfile_2dd -i toto.dat Or one can use the following C++ code: Diaphony . hpp test ; DiscrepancyStatistics stats ; Pointset < D , double , Point > pts ; //We assume pts is filled stats . nbpts = pts . size (); //Can be done several times if we need to average over //several stochastic pointsets double diaphony = 0 ; test . compute < D , double , Point > ( pts , diaphony ) stats . addValue ( diaphony ); stats . computeStatistics (); std :: cout << stats << std :: endl ; Results Stochastic sampler ./bin/discrepancy/Diaphony_fromfile_2dd -i stratified_1024.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 1024.00000 0.00977 0.00000 0.00953 0.01014 10.00000 \u2026 ./bin/discrepancy/Diaphony_fromfile_2dd -i stratified_4096.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 4096.00000 0.00347 0.00000 0.00342 0.00350 10.00000 \u2026 Deterministic sampler ./bin/discrepancy/Diaphony_fromfile_2dd -i sobol_1024.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 1024.00000 0.00516 0.00000 0.00516 0.00516 1.00000 ./bin/discrepancy/Diaphony_fromfile_2dd -i sobol_4096.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 4096.00000 0.00151 0.00000 0.00151 0.00151 1.00000","title":"Diaphony"},{"location":"discrepancy_diaphony/#diaphony","text":"","title":"Diaphony"},{"location":"discrepancy_diaphony/#files","text":"src/discrepancy/Diaphony.hpp src/bin/discrepancy/Diaphony_2dd.cpp src/bin/discrepancy/Diaphony_3dd.cpp src/bin/discrepancy/Diaphony_4dd.cpp","title":"Files"},{"location":"discrepancy_diaphony/#description","text":"Diaphony is a metric of point set uniformity closely related to discrepancy. This tool computes the diaphony in s(N^2) time, with N points in dimension s. from ZINTERHOF, P. 1976. Uber einige Absch~itzungen bei der Approximation von Funktionen mit Gleichverteilungsmethoden. Sitzungsber. Osterr. Akad. Wiss. Math.-Natur. K1. H 185, 121-132.","title":"Description"},{"location":"discrepancy_diaphony/#license","text":"BSD, see Diaphony.hpp","title":"License"},{"location":"discrepancy_diaphony/#execution","text":"Parameters: [HELP] -h [string] Displays this help message -i [string] The input pointsets -o [string] The output discrepancies -s [uint] The number of samples to read (if computing from a sequence) --silent Silent mode --brute Output brute values instead of computing the statistics To evaluate the diaphony of an input 2D point set, one can use the following client line command: ./bin/discrepancy/Diaphony_fromfile_2dd -i toto.dat Or one can use the following C++ code: Diaphony . hpp test ; DiscrepancyStatistics stats ; Pointset < D , double , Point > pts ; //We assume pts is filled stats . nbpts = pts . size (); //Can be done several times if we need to average over //several stochastic pointsets double diaphony = 0 ; test . compute < D , double , Point > ( pts , diaphony ) stats . addValue ( diaphony ); stats . computeStatistics (); std :: cout << stats << std :: endl ;","title":"Execution"},{"location":"discrepancy_diaphony/#results","text":"Stochastic sampler ./bin/discrepancy/Diaphony_fromfile_2dd -i stratified_1024.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 1024.00000 0.00977 0.00000 0.00953 0.01014 10.00000 \u2026 ./bin/discrepancy/Diaphony_fromfile_2dd -i stratified_4096.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 4096.00000 0.00347 0.00000 0.00342 0.00350 10.00000 \u2026 Deterministic sampler ./bin/discrepancy/Diaphony_fromfile_2dd -i sobol_1024.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 1024.00000 0.00516 0.00000 0.00516 0.00516 1.00000 ./bin/discrepancy/Diaphony_fromfile_2dd -i sobol_4096.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 4096.00000 0.00151 0.00000 0.00151 0.00151 1.00000","title":"Results"},{"location":"discrepancy_generalized_l2_disc/","text":"Generalized L2 Discrepancy Files src/discrepancy/GeneralizedL2Discrepancy.hpp src/bin/discrepancy/GeneralizedL2Discrepancy_2dd.cpp Description This tool computes the Generalized L2 discrepancy of an input pointset using the following formula from [Hic98] . License BSD, see GeneralizedL2Discrepancy.hpp Execution Parameters: \\[HELP\\] -h \\[string\\] Displays this help message -i \\[string\\] The input pointsets -o \\[string\\] The output discrepancies -s \\[uint\\] The number of samples to read (if computing from a sequence) --silent Silent mode --brute Output brute values instead of computing the statistics --log Computes the discrepancy in log values To evaluate the discrepancy of an input 2D point set, one can use the following client line command: ./bin/discrepancy/GeneralizedL2Discrepancy\\_fromfile\\_2dd -i toto.dat Or one can use the following C++ code: GeneralizedL2Discrepancy . hpp discrepancy_test ; DiscrepancyStatistics stats ; Pointset < D , double , Point > pts ; //We assume pts is filled stats . nbpts = pts . size (); //Can be done several times if we need to average over //several stochastic pointsets double discrepancy = 0 ; discrepancy_test . compute < D , double , Point > ( pts , discrepancy ) stats . addValue ( discrepancy ); stats . computeStatistics (); std :: cout << stats << std :: endl ; Results Stochastic sampler ./bin/discrepancy/GeneralizedL2Discrepancy\\_fromfile\\_2dd -i stratified\\_256.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 256 0.0105272 5.96467e-07 0.00951201 0.0116941 10 \u2026 ./bin/discrepancy/GeneralizedL2Discrepancy\\_fromfile\\_2dd -i stratified\\_1024.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 1024 0.00391803 5.39822e-08 0.00361717 0.00435023 10 \u2026 ./bin/discrepancy/GeneralizedL2Discrepancy\\_fromfile\\_2dd -i stratified\\_4096.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 4096 0.00139183 2.0377e-09 0.00129969 0.00146937 10 \u2026 Deterministic sampler ./bin/discrepancy/GeneralizedL2Discrepancy\\_fromfile\\_2dd -i sobol\\_1024.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 1024 0.00117859 0 0.00117859 0.00117859 1 ./bin/discrepancy/GeneralizedL2Discrepancy\\_fromfile\\_2dd -i sobol\\_4096.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 4096 0.000307601 0 0.000307601 0.000307601 1","title":"Generalized L2 Discrepancy"},{"location":"discrepancy_generalized_l2_disc/#generalized-l2-discrepancy","text":"","title":"Generalized L2 Discrepancy"},{"location":"discrepancy_generalized_l2_disc/#files","text":"src/discrepancy/GeneralizedL2Discrepancy.hpp src/bin/discrepancy/GeneralizedL2Discrepancy_2dd.cpp","title":"Files"},{"location":"discrepancy_generalized_l2_disc/#description","text":"This tool computes the Generalized L2 discrepancy of an input pointset using the following formula from [Hic98] .","title":"Description"},{"location":"discrepancy_generalized_l2_disc/#license","text":"BSD, see GeneralizedL2Discrepancy.hpp","title":"License"},{"location":"discrepancy_generalized_l2_disc/#execution","text":"Parameters: \\[HELP\\] -h \\[string\\] Displays this help message -i \\[string\\] The input pointsets -o \\[string\\] The output discrepancies -s \\[uint\\] The number of samples to read (if computing from a sequence) --silent Silent mode --brute Output brute values instead of computing the statistics --log Computes the discrepancy in log values To evaluate the discrepancy of an input 2D point set, one can use the following client line command: ./bin/discrepancy/GeneralizedL2Discrepancy\\_fromfile\\_2dd -i toto.dat Or one can use the following C++ code: GeneralizedL2Discrepancy . hpp discrepancy_test ; DiscrepancyStatistics stats ; Pointset < D , double , Point > pts ; //We assume pts is filled stats . nbpts = pts . size (); //Can be done several times if we need to average over //several stochastic pointsets double discrepancy = 0 ; discrepancy_test . compute < D , double , Point > ( pts , discrepancy ) stats . addValue ( discrepancy ); stats . computeStatistics (); std :: cout << stats << std :: endl ;","title":"Execution"},{"location":"discrepancy_generalized_l2_disc/#results","text":"Stochastic sampler ./bin/discrepancy/GeneralizedL2Discrepancy\\_fromfile\\_2dd -i stratified\\_256.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 256 0.0105272 5.96467e-07 0.00951201 0.0116941 10 \u2026 ./bin/discrepancy/GeneralizedL2Discrepancy\\_fromfile\\_2dd -i stratified\\_1024.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 1024 0.00391803 5.39822e-08 0.00361717 0.00435023 10 \u2026 ./bin/discrepancy/GeneralizedL2Discrepancy\\_fromfile\\_2dd -i stratified\\_4096.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 4096 0.00139183 2.0377e-09 0.00129969 0.00146937 10 \u2026 Deterministic sampler ./bin/discrepancy/GeneralizedL2Discrepancy\\_fromfile\\_2dd -i sobol\\_1024.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 1024 0.00117859 0 0.00117859 0.00117859 1 ./bin/discrepancy/GeneralizedL2Discrepancy\\_fromfile\\_2dd -i sobol\\_4096.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 4096 0.000307601 0 0.000307601 0.000307601 1","title":"Results"},{"location":"discrepancy_l2_disc/","text":"L2 Discrepancy Files src/discrepancy/L2Discrepancy.hpp src/bin/discrepancy/L2Discrepancy_2dd.cpp Description This tool computes the L2 discrepancy of an input pointset using the following formula from [Hic98] . License BSD, see L2Discrepancy.hpp Execution Parameters: [HELP] -h [string] Displays this help message -i [string] The input pointsets -o [string] The output discrepancies -s [uint] The number of samples to read (if computing from a sequence) --silent Silent mode --brute Output brute values instead of computing the statistics To evaluate the discrepancy of an input 2D point set, one can use the following client line command: ./bin/discrepancy/L2Discrepancy_fromfile_2dd -i toto.dat Or one can use the following C++ code: L2Discrepancy . hpp discrepancy_test ; DiscrepancyStatistics stats ; Pointset < D , double , Point > pts ; //We assume pts is filled stats . nbpts = pts . size (); //Can be done several times if we need to average over //several stochastic pointsets double discrepancy = 0 ; discrepancy_test . compute < D , double , Point > ( pts , discrepancy ) stats . addValue ( discrepancy ); stats . computeStatistics (); std :: cout << stats << std :: endl ; Results Stochastic sampler ./bin/discrepancy/L2Discrepancy_fromfile_2dd -i stratified_256.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 256 0.00633396 1.03228e-07 0.0058098 0.00677085 10 \u2026 ./bin/discrepancy/L2Discrepancy_fromfile_2dd -i stratified_1024.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 1024 0.00225664 4.18443e-09 0.00213154 0.00233792 10 \u2026 ./bin/discrepancy/L2Discrepancy_fromfile_2dd -i stratified_4096.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 4096 0.00081179 1.4945e-09 0.000766782 0.000901231 10 \u2026 Deterministic sampler ./bin/discrepancy/L2Discrepancy_fromfile_2dd -i sobol_1024.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 1024 0.000867928 0 0.000867928 0.000867928 1 ./bin/discrepancy/L2Discrepancy_fromfile_2dd -i sobol_4096.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 4096 0.000234269 0 0.000234269 0.000234269 1","title":"L2 Discrepancy"},{"location":"discrepancy_l2_disc/#l2-discrepancy","text":"","title":"L2 Discrepancy"},{"location":"discrepancy_l2_disc/#files","text":"src/discrepancy/L2Discrepancy.hpp src/bin/discrepancy/L2Discrepancy_2dd.cpp","title":"Files"},{"location":"discrepancy_l2_disc/#description","text":"This tool computes the L2 discrepancy of an input pointset using the following formula from [Hic98] .","title":"Description"},{"location":"discrepancy_l2_disc/#license","text":"BSD, see L2Discrepancy.hpp","title":"License"},{"location":"discrepancy_l2_disc/#execution","text":"Parameters: [HELP] -h [string] Displays this help message -i [string] The input pointsets -o [string] The output discrepancies -s [uint] The number of samples to read (if computing from a sequence) --silent Silent mode --brute Output brute values instead of computing the statistics To evaluate the discrepancy of an input 2D point set, one can use the following client line command: ./bin/discrepancy/L2Discrepancy_fromfile_2dd -i toto.dat Or one can use the following C++ code: L2Discrepancy . hpp discrepancy_test ; DiscrepancyStatistics stats ; Pointset < D , double , Point > pts ; //We assume pts is filled stats . nbpts = pts . size (); //Can be done several times if we need to average over //several stochastic pointsets double discrepancy = 0 ; discrepancy_test . compute < D , double , Point > ( pts , discrepancy ) stats . addValue ( discrepancy ); stats . computeStatistics (); std :: cout << stats << std :: endl ;","title":"Execution"},{"location":"discrepancy_l2_disc/#results","text":"Stochastic sampler ./bin/discrepancy/L2Discrepancy_fromfile_2dd -i stratified_256.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 256 0.00633396 1.03228e-07 0.0058098 0.00677085 10 \u2026 ./bin/discrepancy/L2Discrepancy_fromfile_2dd -i stratified_1024.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 1024 0.00225664 4.18443e-09 0.00213154 0.00233792 10 \u2026 ./bin/discrepancy/L2Discrepancy_fromfile_2dd -i stratified_4096.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 4096 0.00081179 1.4945e-09 0.000766782 0.000901231 10 \u2026 Deterministic sampler ./bin/discrepancy/L2Discrepancy_fromfile_2dd -i sobol_1024.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 1024 0.000867928 0 0.000867928 0.000867928 1 ./bin/discrepancy/L2Discrepancy_fromfile_2dd -i sobol_4096.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 4096 0.000234269 0 0.000234269 0.000234269 1","title":"Results"},{"location":"discrepancy_star_disc/","text":"Star Discrepancy Files src/discrepancy/StarDiscrepancy.hpp src/bin/discrepancy/StarDiscrepancy_2dd.cpp Description This tool computes the Star/Linf discrepancy of an input pointset using an O(n^2) O(n^2) algorithm which returns the exact Linf discrepancy value. Execution Parameters: [HELP] -h [string] Displays this help message -i [string] The input pointsets -o [string] The output discrepancies -s [uint] The number of samples to read (if computing from a sequence) --silent Silent mode --brute Output brute values instead of computing the statistics To evaluate the discrepancy of an input 2D point set, one can use the following client line command: ./bin/discrepancy/StarDiscrepancy_fromfile_2dd -i toto.dat Or one can use the following C++ code: StarDiscrepancy . hpp discrepancy_test ; DiscrepancyStatistics stats ; Pointset < D , double , Point > pts ; //We assume pts is filled stats . nbpts = pts . size (); //Can be done several times if we need to average over //several stochastic pointsets double discrepancy = 0 ; discrepancy_test . compute < D , double , Point > ( pts , discrepancy ) stats . addValue ( discrepancy ); stats . computeStatistics (); std :: cout << stats << std :: endl ; License BSD, see StarDiscrepancy.hpp Results Stochastic sampler ./bin/discrepancy/StarDiscrepancy_fromfile_2dd -i stratified_256.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 256 0.032341 7.52055e-06 0.0297618 0.0390747 10 \u2026 ./bin/discrepancy/StarDiscrepancy_fromfile_2dd -i stratified_1024.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 1024 0.01356 3.72309e-07 0.0124115 0.0143659 10 \u2026 ./bin/discrepancy/StarDiscrepancy_fromfile_2dd -i stratified_4096.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 4096 0.00513415 2.27188e-07 0.00441079 0.00569296 10 \u2026 Deterministic sampler ./bin/discrepancy/StarDiscrepancy_fromfile_2dd -i sobol_1024.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 1024 0.00429916 0 0.00429916 0.00429916 1 ./bin/discrepancy/StarDiscrepancy_fromfile_2dd -i sobol_4096.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 4096 0.00132918 0 0.00132918 0.00132918 1","title":"Star discrepancy"},{"location":"discrepancy_star_disc/#star-discrepancy","text":"","title":"Star Discrepancy"},{"location":"discrepancy_star_disc/#files","text":"src/discrepancy/StarDiscrepancy.hpp src/bin/discrepancy/StarDiscrepancy_2dd.cpp","title":"Files"},{"location":"discrepancy_star_disc/#description","text":"This tool computes the Star/Linf discrepancy of an input pointset using an O(n^2) O(n^2) algorithm which returns the exact Linf discrepancy value.","title":"Description"},{"location":"discrepancy_star_disc/#execution","text":"Parameters: [HELP] -h [string] Displays this help message -i [string] The input pointsets -o [string] The output discrepancies -s [uint] The number of samples to read (if computing from a sequence) --silent Silent mode --brute Output brute values instead of computing the statistics To evaluate the discrepancy of an input 2D point set, one can use the following client line command: ./bin/discrepancy/StarDiscrepancy_fromfile_2dd -i toto.dat Or one can use the following C++ code: StarDiscrepancy . hpp discrepancy_test ; DiscrepancyStatistics stats ; Pointset < D , double , Point > pts ; //We assume pts is filled stats . nbpts = pts . size (); //Can be done several times if we need to average over //several stochastic pointsets double discrepancy = 0 ; discrepancy_test . compute < D , double , Point > ( pts , discrepancy ) stats . addValue ( discrepancy ); stats . computeStatistics (); std :: cout << stats << std :: endl ;","title":"Execution"},{"location":"discrepancy_star_disc/#license","text":"BSD, see StarDiscrepancy.hpp","title":"License"},{"location":"discrepancy_star_disc/#results","text":"Stochastic sampler ./bin/discrepancy/StarDiscrepancy_fromfile_2dd -i stratified_256.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 256 0.032341 7.52055e-06 0.0297618 0.0390747 10 \u2026 ./bin/discrepancy/StarDiscrepancy_fromfile_2dd -i stratified_1024.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 1024 0.01356 3.72309e-07 0.0124115 0.0143659 10 \u2026 ./bin/discrepancy/StarDiscrepancy_fromfile_2dd -i stratified_4096.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 4096 0.00513415 2.27188e-07 0.00441079 0.00569296 10 \u2026 Deterministic sampler ./bin/discrepancy/StarDiscrepancy_fromfile_2dd -i sobol_1024.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 1024 0.00429916 0 0.00429916 0.00429916 1 ./bin/discrepancy/StarDiscrepancy_fromfile_2dd -i sobol_4096.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 4096 0.00132918 0 0.00132918 0.00132918 1","title":"Results"},{"location":"discrepancy_symmetric_l2_disc/","text":"Symmetric L2 Discrepancy Files src/discrepancy/SymmetricL2Discrepancy.hpp src/bin/discrepancy/SymmetricL2Discrepancy_2dd.cpp Description This tool computes the Symmetric L2 discrepancy of an input pointset using the following formula from [Hic98] . License BSD, see SymmetricL2Discrepancy.hpp Execution Parameters: [HELP] -h [string] Displays this help message -i [string] The input pointsets -o [string] The output discrepancies -s [uint] The number of samples to read (if computing from a sequence) --silent Silent mode --brute Output brute values instead of computing the statistics To evaluate the discrepancy of an input 2D point set, one can use the following client line command: ./bin/discrepancy/SymmetricL2Discrepancy_fromfile_2dd -i toto.dat Or one can use the following C++ code: SymmetricL2Discrepancy . hpp discrepancy_test ; DiscrepancyStatistics stats ; Pointset < D , double , Point > pts ; //We assume pts is filled stats . nbpts = pts . size (); //Can be done several times if we need to average over //several stochastic pointsets double discrepancy = 0 ; discrepancy_test . compute < D , double , Point > ( pts , discrepancy ) stats . addValue ( discrepancy ); stats . computeStatistics (); std :: cout << stats << std :: endl ; Results Stochastic sampler ./bin/discrepancy/SymmetricL2Discrepancy_fromfile_2dd -i stratified_256.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 256 0.0251765 2.66344e-06 0.0230421 0.0275544 10 \u2026 ./bin/discrepancy/SymmetricL2Discrepancy_fromfile_2dd -i stratified_1024.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 1024 0.00883385 1.2468e-07 0.00825203 0.00937224 10 \u2026 ./bin/discrepancy/SymmetricL2Discrepancy_fromfile_2dd -i stratified_4096.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 4096 0.0032218 1.45414e-08 0.00309627 0.00343734 10 \u2026 Deterministic sampler ./bin/discrepancy/SymmetricL2Discrepancy_fromfile_2dd -i sobol_1024.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 1024 0.00317465 0 0.00317465 0.00317465 1 ./bin/discrepancy/SymmetricL2Discrepancy_fromfile_2dd -i sobol_4096.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 4096 0.000862486 0 0.000862486 0.000862486 1","title":"Symmetric L2 Discrepancy"},{"location":"discrepancy_symmetric_l2_disc/#symmetric-l2-discrepancy","text":"","title":"Symmetric L2 Discrepancy"},{"location":"discrepancy_symmetric_l2_disc/#files","text":"src/discrepancy/SymmetricL2Discrepancy.hpp src/bin/discrepancy/SymmetricL2Discrepancy_2dd.cpp","title":"Files"},{"location":"discrepancy_symmetric_l2_disc/#description","text":"This tool computes the Symmetric L2 discrepancy of an input pointset using the following formula from [Hic98] .","title":"Description"},{"location":"discrepancy_symmetric_l2_disc/#license","text":"BSD, see SymmetricL2Discrepancy.hpp","title":"License"},{"location":"discrepancy_symmetric_l2_disc/#execution","text":"Parameters: [HELP] -h [string] Displays this help message -i [string] The input pointsets -o [string] The output discrepancies -s [uint] The number of samples to read (if computing from a sequence) --silent Silent mode --brute Output brute values instead of computing the statistics To evaluate the discrepancy of an input 2D point set, one can use the following client line command: ./bin/discrepancy/SymmetricL2Discrepancy_fromfile_2dd -i toto.dat Or one can use the following C++ code: SymmetricL2Discrepancy . hpp discrepancy_test ; DiscrepancyStatistics stats ; Pointset < D , double , Point > pts ; //We assume pts is filled stats . nbpts = pts . size (); //Can be done several times if we need to average over //several stochastic pointsets double discrepancy = 0 ; discrepancy_test . compute < D , double , Point > ( pts , discrepancy ) stats . addValue ( discrepancy ); stats . computeStatistics (); std :: cout << stats << std :: endl ;","title":"Execution"},{"location":"discrepancy_symmetric_l2_disc/#results","text":"Stochastic sampler ./bin/discrepancy/SymmetricL2Discrepancy_fromfile_2dd -i stratified_256.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 256 0.0251765 2.66344e-06 0.0230421 0.0275544 10 \u2026 ./bin/discrepancy/SymmetricL2Discrepancy_fromfile_2dd -i stratified_1024.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 1024 0.00883385 1.2468e-07 0.00825203 0.00937224 10 \u2026 ./bin/discrepancy/SymmetricL2Discrepancy_fromfile_2dd -i stratified_4096.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 4096 0.0032218 1.45414e-08 0.00309627 0.00343734 10 \u2026 Deterministic sampler ./bin/discrepancy/SymmetricL2Discrepancy_fromfile_2dd -i sobol_1024.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 1024 0.00317465 0 0.00317465 0.00317465 1 ./bin/discrepancy/SymmetricL2Discrepancy_fromfile_2dd -i sobol_4096.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 4096 0.000862486 0 0.000862486 0.000862486 1","title":"Results"},{"location":"discrepancy_unanchored_l2_disc/","text":"Unanchored L2 Discrepancy Files src/discrepancy/UnanchoredL2Discrepancy.hpp src/bin/discrepancy/UnanchoredL2Discrepancy_2dd.cpp. Description This tool computes the Unanchored L2 discrepancy of an input pointset using the following formula from [Lem09] . License BSD, see UnanchoredL2Discrepancy.hpp . Execution Parameters: [HELP] -h [string] Displays this help message -i [string] The input pointsets -o [string] The output discrepancies -s [uint] The number of samples to read (if computing from a sequence) --silent Silent mode --brute Output brute values instead of computing the statistics To evaluate the discrepancy of an input 2D point set, one can use the following client line command: ./bin/discrepancy/UnanchoredL2Discrepancy_fromfile_2dd -i toto.dat Or one can use the following C++ code: UnanchoredL2Discrepancy . hpp discrepancy_test ; DiscrepancyStatistics stats ; Pointset < D , double , Point > pts ; //We assume pts is filled stats . nbpts = pts . size (); //Can be done several times if we need to average over //several stochastic pointsets double discrepancy = 0 ; discrepancy_test . compute < D , double , Point > ( pts , discrepancy ) stats . addValue ( discrepancy ); stats . computeStatistics (); std :: cout << stats << std :: endl ; Results Stochastic sampler ./bin/discrepancy/UnanchoredL2Discrepancy_fromfile_2dd -i stratified_256.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 256 0.00352541 3.02457e-08 0.00317938 0.00378527 10 \u2026 ./bin/discrepancy/UnanchoredL2Discrepancy_fromfile_2dd -i stratified_1024.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 1024 0.00126314 9.53465e-10 0.0012084 0.00130749 10 \u2026 ./bin/discrepancy/UnanchoredL2Discrepancy_fromfile_2dd -i stratified_4096.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 4096 0.00046235 1.53657e-10 0.000438963 0.000485913 10 \u2026 Deterministic sampler ./bin/discrepancy/UnanchoredL2Discrepancy_fromfile_2dd -i sobol_1024.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 1024 0.000553279 0 0.000553279 0.000553279 1 ./bin/discrepancy/UnanchoredL2Discrepancy_fromfile_2dd -i sobol_4096.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 4096 0.000160965 0 0.000160965 0.000160965 1","title":"Unanchored L2 Discrepancy"},{"location":"discrepancy_unanchored_l2_disc/#unanchored-l2-discrepancy","text":"","title":"Unanchored L2 Discrepancy"},{"location":"discrepancy_unanchored_l2_disc/#files","text":"src/discrepancy/UnanchoredL2Discrepancy.hpp src/bin/discrepancy/UnanchoredL2Discrepancy_2dd.cpp.","title":"Files"},{"location":"discrepancy_unanchored_l2_disc/#description","text":"This tool computes the Unanchored L2 discrepancy of an input pointset using the following formula from [Lem09] .","title":"Description"},{"location":"discrepancy_unanchored_l2_disc/#license","text":"BSD, see UnanchoredL2Discrepancy.hpp .","title":"License"},{"location":"discrepancy_unanchored_l2_disc/#execution","text":"Parameters: [HELP] -h [string] Displays this help message -i [string] The input pointsets -o [string] The output discrepancies -s [uint] The number of samples to read (if computing from a sequence) --silent Silent mode --brute Output brute values instead of computing the statistics To evaluate the discrepancy of an input 2D point set, one can use the following client line command: ./bin/discrepancy/UnanchoredL2Discrepancy_fromfile_2dd -i toto.dat Or one can use the following C++ code: UnanchoredL2Discrepancy . hpp discrepancy_test ; DiscrepancyStatistics stats ; Pointset < D , double , Point > pts ; //We assume pts is filled stats . nbpts = pts . size (); //Can be done several times if we need to average over //several stochastic pointsets double discrepancy = 0 ; discrepancy_test . compute < D , double , Point > ( pts , discrepancy ) stats . addValue ( discrepancy ); stats . computeStatistics (); std :: cout << stats << std :: endl ;","title":"Execution"},{"location":"discrepancy_unanchored_l2_disc/#results","text":"Stochastic sampler ./bin/discrepancy/UnanchoredL2Discrepancy_fromfile_2dd -i stratified_256.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 256 0.00352541 3.02457e-08 0.00317938 0.00378527 10 \u2026 ./bin/discrepancy/UnanchoredL2Discrepancy_fromfile_2dd -i stratified_1024.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 1024 0.00126314 9.53465e-10 0.0012084 0.00130749 10 \u2026 ./bin/discrepancy/UnanchoredL2Discrepancy_fromfile_2dd -i stratified_4096.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 4096 0.00046235 1.53657e-10 0.000438963 0.000485913 10 \u2026 Deterministic sampler ./bin/discrepancy/UnanchoredL2Discrepancy_fromfile_2dd -i sobol_1024.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 1024 0.000553279 0 0.000553279 0.000553279 1 ./bin/discrepancy/UnanchoredL2Discrepancy_fromfile_2dd -i sobol_4096.dat #Nbpts #Mean #Var #Min #Max #NbPtsets 4096 0.000160965 0 0.000160965 0.000160965 1","title":"Results"},{"location":"doxygen/","text":"Doxygen documentation of the main classes.","title":"Doxygen"},{"location":"integration_box_arrangement/","text":"Integration Box Arrangement Files src/integration/IntegrationBoxArrangement.hpp src/integration/arrangement/TriangleArrangement.hpp src/integration/arrangement/BoxesAligned.hpp src/bin/integration/IntegrationBoxArrangement_fromfile_2dd.cpp Description To palliate the absence of analytical expression for natural images, we instead try to integrate analytical arrangements of boxes or triangles. Such arrangement present analytical expression for their integrand and are therefore a better reference when testing the behavior of a sampler when used to approximate an integrand using a Monte Carlo estimator. Note that this test is not yet finished. Due to numerical imprecisions (?), we can\u2019t generate too many triangles and boxes within the arrangement. Furthermore, the Fourier spectrum of the arrangement is not yet controllable. However, this second issue might be solved by distributing shapes following colored noise distributions (green noise, pink noise, blue noise). as each color of noise seems to affect a particular range of frequencies. Note This tool requires the CGAL library. You would need also to set cmake .. -DUSE_CGAL=true when generating the project. License BSD, see IntegrationBoxArrangement.hpp Execution Parameters: [HELP] -h [string] Displays this help message -i [string] The input pointsets -o [string] The output integration results -s [uint] The number of samples to read (if integrating from a sequence) --silent Silent mode --brute Output brute values instead of computing the statistics -r [string] Rasterized output To integrate over a function using an input 2D point set, we can use the following client line command: ./bin/integration/IntegrationBoxArrangement_fromfile_2dd -i toto.dat Or one can use the following C++ code: IntegrationBoxArrangement integration_test ; IntegrationStatistics stats ; Pointset < D , double , Point > pts ; //We assume pts is filled stats . nbpts = pts . size (); //Can be done several times if we need to average over //several stochastic pointsets double analytical = 0 ; double integration = 0 ; integration_test . compute < D , double , Point > ( pts , integration , analytical ) stats . setAnalytical ( analytical ); stats . addValue ( integration ); stats . computeStatistics (); std :: cout << stats << std :: endl ; Results Stochastic sampler ./bin/integration/IntegrationBoxArrangement_fromfile_2dd -i stratified_256.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 256 173.794 117.155 154.68 192.285 176.922 115.223 10 \u2026 ./bin/integration/IntegrationBoxArrangement_fromfile_2dd -i stratified_1024.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 1024 176.459 36.3116 165.905 184.707 176.922 32.8946 10 \u2026 ./bin/integration/IntegrationBoxArrangement_fromfile_2dd -i stratified_4096.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 4096 175.829 4.20551 172.211 178.462 176.922 4.97822 10 \u2026 Deterministic sampler ./bin/integration/IntegrationBoxArrangement_fromfile_2dd -i sobol_1024.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 1024 168.114 0 168.114 168.114 176.922 77.5708 1 ./bin/integration/IntegrationBoxArrangement_fromfile_2dd -i sobol_4096.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 4096 176.217 0 176.217 176.217 176.922 0.49652 1","title":"Box arrangement"},{"location":"integration_box_arrangement/#integration-box-arrangement","text":"","title":"Integration Box Arrangement"},{"location":"integration_box_arrangement/#files","text":"src/integration/IntegrationBoxArrangement.hpp src/integration/arrangement/TriangleArrangement.hpp src/integration/arrangement/BoxesAligned.hpp src/bin/integration/IntegrationBoxArrangement_fromfile_2dd.cpp","title":"Files"},{"location":"integration_box_arrangement/#description","text":"To palliate the absence of analytical expression for natural images, we instead try to integrate analytical arrangements of boxes or triangles. Such arrangement present analytical expression for their integrand and are therefore a better reference when testing the behavior of a sampler when used to approximate an integrand using a Monte Carlo estimator. Note that this test is not yet finished. Due to numerical imprecisions (?), we can\u2019t generate too many triangles and boxes within the arrangement. Furthermore, the Fourier spectrum of the arrangement is not yet controllable. However, this second issue might be solved by distributing shapes following colored noise distributions (green noise, pink noise, blue noise). as each color of noise seems to affect a particular range of frequencies. Note This tool requires the CGAL library. You would need also to set cmake .. -DUSE_CGAL=true when generating the project.","title":"Description"},{"location":"integration_box_arrangement/#license","text":"BSD, see IntegrationBoxArrangement.hpp","title":"License"},{"location":"integration_box_arrangement/#execution","text":"Parameters: [HELP] -h [string] Displays this help message -i [string] The input pointsets -o [string] The output integration results -s [uint] The number of samples to read (if integrating from a sequence) --silent Silent mode --brute Output brute values instead of computing the statistics -r [string] Rasterized output To integrate over a function using an input 2D point set, we can use the following client line command: ./bin/integration/IntegrationBoxArrangement_fromfile_2dd -i toto.dat Or one can use the following C++ code: IntegrationBoxArrangement integration_test ; IntegrationStatistics stats ; Pointset < D , double , Point > pts ; //We assume pts is filled stats . nbpts = pts . size (); //Can be done several times if we need to average over //several stochastic pointsets double analytical = 0 ; double integration = 0 ; integration_test . compute < D , double , Point > ( pts , integration , analytical ) stats . setAnalytical ( analytical ); stats . addValue ( integration ); stats . computeStatistics (); std :: cout << stats << std :: endl ;","title":"Execution"},{"location":"integration_box_arrangement/#results","text":"Stochastic sampler ./bin/integration/IntegrationBoxArrangement_fromfile_2dd -i stratified_256.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 256 173.794 117.155 154.68 192.285 176.922 115.223 10 \u2026 ./bin/integration/IntegrationBoxArrangement_fromfile_2dd -i stratified_1024.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 1024 176.459 36.3116 165.905 184.707 176.922 32.8946 10 \u2026 ./bin/integration/IntegrationBoxArrangement_fromfile_2dd -i stratified_4096.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 4096 175.829 4.20551 172.211 178.462 176.922 4.97822 10 \u2026 Deterministic sampler ./bin/integration/IntegrationBoxArrangement_fromfile_2dd -i sobol_1024.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 1024 168.114 0 168.114 168.114 176.922 77.5708 1 ./bin/integration/IntegrationBoxArrangement_fromfile_2dd -i sobol_4096.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 4096 176.217 0 176.217 176.217 176.922 0.49652 1","title":"Results"},{"location":"integration_centered_gaussian/","text":"Integration Centered Gaussian Files src/integration/IntegrationCenteredGaussian.hpp src/bin/integration/IntegrationCenteredGaussian_fromfile_2dd.cpp.cpp Description This test uses an input pointset to approximate the CDF of a Gaussian function using a Monte Carlo estimator. Note that in this test the gaussian is centered at 0.5^D 0.5^D (points are scaled to [0, 1]^D [0, 1]^D ), for an analytical value of ~1. This test exists only in 2D. Note that due to our inability to find any analytical function to determine the area of a cropped gaussian, we devised independent tests for a centered uncropped gaussian and a 1/4 cropped gaussian (which both have exact analytical values) and a generic gaussian where the analytical value is estimated using a Monte Carlo estimator using 10e6 regular samples. License BSD, see IntegrationCenteredGaussian.hpp Execution Parameters: [HELP] --outputfunc Outputs the integrated function in func.dat (plottable with gnuplot) --outputimg Outputs the integrated function in func.png -h [string] Displays this help message -i [string] The input pointsets -o [string] The output integration results -s [uint] The number of samples to read (if integrating from a sequence) --silent Silent mode --brute Output brute values instead of computing the statistics To integrate over a function using an input 2D point set, we can use the following client line command: ./bin/integration/IntegrationCenteredGaussian_fromfile_2dd -i toto.dat Or one can use the following C++ code: IntegrationCenteredGaussian integration_test ; IntegrationStatistics stats ; Pointset < D , double , Point > pts ; //We assume pts is filled stats . nbpts = pts . size (); //Can be done several times if we need to average over //several stochastic pointsets double analytical = 0 ; double integration = 0 ; integration_test . compute < D , double , Point > ( pts , integration , analytical ) stats . setAnalytical ( analytical ); stats . addValue ( integration ); stats . computeStatistics (); std :: cout << stats << std :: endl ; Results Stochastic sampler ./bin/integration/IntegrationCenteredGaussian_fromfile_2dd -i stratified_256.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 256 1.01654 0.000608383 0.979811 1.06037 1 0.000821097 10 \u2026 ./bin/integration/IntegrationCenteredGaussian_fromfile_2dd -i stratified_1024.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 1024 0.99999 7.22086e-05 0.984586 1.01211 1 6.49878e-05 10 \u2026 ./bin/integration/IntegrationCenteredGaussian_fromfile_2dd -i stratified_4096.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 4096 1.00112 3.73298e-06 0.998042 1.00392 1 4.61976e-06 10 \u2026 Deterministic sampler ./bin/integration/IntegrationCenteredGaussian_fromfile_2dd -i sobol_1024.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 1024 1.00034 0 1.00034 1.00034 1 1.18955e-07 1 ./bin/integration/IntegrationCenteredGaussian_fromfile_2dd -i sobol_4096.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 4096 0.999995 0 0.999995 0.999995 1 2.59188e-11 1","title":"Centered Gaussian"},{"location":"integration_centered_gaussian/#integration-centered-gaussian","text":"","title":"Integration Centered Gaussian"},{"location":"integration_centered_gaussian/#files","text":"src/integration/IntegrationCenteredGaussian.hpp src/bin/integration/IntegrationCenteredGaussian_fromfile_2dd.cpp.cpp","title":"Files"},{"location":"integration_centered_gaussian/#description","text":"This test uses an input pointset to approximate the CDF of a Gaussian function using a Monte Carlo estimator. Note that in this test the gaussian is centered at 0.5^D 0.5^D (points are scaled to [0, 1]^D [0, 1]^D ), for an analytical value of ~1. This test exists only in 2D. Note that due to our inability to find any analytical function to determine the area of a cropped gaussian, we devised independent tests for a centered uncropped gaussian and a 1/4 cropped gaussian (which both have exact analytical values) and a generic gaussian where the analytical value is estimated using a Monte Carlo estimator using 10e6 regular samples.","title":"Description"},{"location":"integration_centered_gaussian/#license","text":"BSD, see IntegrationCenteredGaussian.hpp","title":"License"},{"location":"integration_centered_gaussian/#execution","text":"Parameters: [HELP] --outputfunc Outputs the integrated function in func.dat (plottable with gnuplot) --outputimg Outputs the integrated function in func.png -h [string] Displays this help message -i [string] The input pointsets -o [string] The output integration results -s [uint] The number of samples to read (if integrating from a sequence) --silent Silent mode --brute Output brute values instead of computing the statistics To integrate over a function using an input 2D point set, we can use the following client line command: ./bin/integration/IntegrationCenteredGaussian_fromfile_2dd -i toto.dat Or one can use the following C++ code: IntegrationCenteredGaussian integration_test ; IntegrationStatistics stats ; Pointset < D , double , Point > pts ; //We assume pts is filled stats . nbpts = pts . size (); //Can be done several times if we need to average over //several stochastic pointsets double analytical = 0 ; double integration = 0 ; integration_test . compute < D , double , Point > ( pts , integration , analytical ) stats . setAnalytical ( analytical ); stats . addValue ( integration ); stats . computeStatistics (); std :: cout << stats << std :: endl ;","title":"Execution"},{"location":"integration_centered_gaussian/#results","text":"Stochastic sampler ./bin/integration/IntegrationCenteredGaussian_fromfile_2dd -i stratified_256.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 256 1.01654 0.000608383 0.979811 1.06037 1 0.000821097 10 \u2026 ./bin/integration/IntegrationCenteredGaussian_fromfile_2dd -i stratified_1024.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 1024 0.99999 7.22086e-05 0.984586 1.01211 1 6.49878e-05 10 \u2026 ./bin/integration/IntegrationCenteredGaussian_fromfile_2dd -i stratified_4096.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 4096 1.00112 3.73298e-06 0.998042 1.00392 1 4.61976e-06 10 \u2026 Deterministic sampler ./bin/integration/IntegrationCenteredGaussian_fromfile_2dd -i sobol_1024.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 1024 1.00034 0 1.00034 1.00034 1 1.18955e-07 1 ./bin/integration/IntegrationCenteredGaussian_fromfile_2dd -i sobol_4096.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 4096 0.999995 0 0.999995 0.999995 1 2.59188e-11 1","title":"Results"},{"location":"integration_cornered_gaussian/","text":"Integration IntegrationCorneredGaussian Files src/integration/IntegrationCorneredGaussian.hpp src/bin/integration/IntegrationCorneredGaussian_fromfile_2dd.cpp.cpp Description This test uses an input pointset to approximate the CDF of a cropped Gaussian function using a Monte Carlo estimator. Note that in this test the gaussian is centered at 0^D 0^D (points are scaled to [0, 1]^D [0, 1]^D ), for an analytical value of ~1/4. (as this gaussian is cropped to 1/4 of its real integrand). This test exists only in 2D. Note that due to our inability to find any analytical function to determine the area of a cropped gaussian, we devised independent tests for a centered uncropped gaussian and a 1/4 cropped gaussian (which both have exact analytical values) and a generic gaussian where the analytical value is estimated using a Monte Carlo estimator using 10e6 regular samples. License BSD, see IntegrationCorneredGaussian.hpp Execution Parameters: [HELP] --outputfunc Outputs the integrated function in func.dat (plottable with gnuplot) --outputimg Outputs the integrated function in func.png -h [string] Displays this help message -i [string] The input pointsets -o [string] The output integration results -s [uint] The number of samples to read (if integrating from a sequence) --silent Silent mode --brute Output brute values instead of computing the statistics To integrate over a function using an input 2D point set, we can use the following client line command: ./bin/integration/IntegrationCorneredGaussian_fromfile_2dd -i toto.dat Or one can use the following C++ code: IntegrationCorneredGaussian integration_test ; IntegrationStatistics stats ; Pointset < D , double , Point > pts ; //We assume pts is filled stats . nbpts = pts . size (); //Can be done several times if we need to average over //several stochastic pointsets double analytical = 0 ; double integration = 0 ; integration_test . compute < D , double , Point > ( pts , integration , analytical ) stats . setAnalytical ( analytical ); stats . addValue ( integration ); stats . computeStatistics (); std :: cout << stats << std :: endl ; Results Stochastic sampler ./bin/integration/IntegrationCorneredGaussian_fromfile_2dd -i stratified_256.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 256 0.249767 1.78588e-05 0.240248 0.256679 0.25 1.61271e-05 10 \u2026 ./bin/integration/IntegrationCorneredGaussian_fromfile_2dd -i stratified_1024.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 1024 0.249748 7.42086e-07 0.248584 0.251039 0.25 7.31222e-07 10 \u2026 ./bin/integration/IntegrationCorneredGaussian_fromfile_2dd -i stratified_4096.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 4096 0.249878 7.96447e-08 0.249494 0.250237 0.25 8.66692e-08 10 \u2026 Deterministic sampler ./bin/integration/IntegrationCorneredGaussian_fromfile_2dd -i sobol_1024.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 1024 0.250991 0 0.250991 0.250991 0.25 9.82109e-07 1 ./bin/integration/IntegrationCorneredGaussian_fromfile_2dd -i sobol_4096.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 4096 0.250259 0 0.250259 0.250259 0.25 6.72357e-08 1","title":"Cornered Gaussian"},{"location":"integration_cornered_gaussian/#integration-integrationcorneredgaussian","text":"","title":"Integration IntegrationCorneredGaussian"},{"location":"integration_cornered_gaussian/#files","text":"src/integration/IntegrationCorneredGaussian.hpp src/bin/integration/IntegrationCorneredGaussian_fromfile_2dd.cpp.cpp","title":"Files"},{"location":"integration_cornered_gaussian/#description","text":"This test uses an input pointset to approximate the CDF of a cropped Gaussian function using a Monte Carlo estimator. Note that in this test the gaussian is centered at 0^D 0^D (points are scaled to [0, 1]^D [0, 1]^D ), for an analytical value of ~1/4. (as this gaussian is cropped to 1/4 of its real integrand). This test exists only in 2D. Note that due to our inability to find any analytical function to determine the area of a cropped gaussian, we devised independent tests for a centered uncropped gaussian and a 1/4 cropped gaussian (which both have exact analytical values) and a generic gaussian where the analytical value is estimated using a Monte Carlo estimator using 10e6 regular samples.","title":"Description"},{"location":"integration_cornered_gaussian/#license","text":"BSD, see IntegrationCorneredGaussian.hpp","title":"License"},{"location":"integration_cornered_gaussian/#execution","text":"Parameters: [HELP] --outputfunc Outputs the integrated function in func.dat (plottable with gnuplot) --outputimg Outputs the integrated function in func.png -h [string] Displays this help message -i [string] The input pointsets -o [string] The output integration results -s [uint] The number of samples to read (if integrating from a sequence) --silent Silent mode --brute Output brute values instead of computing the statistics To integrate over a function using an input 2D point set, we can use the following client line command: ./bin/integration/IntegrationCorneredGaussian_fromfile_2dd -i toto.dat Or one can use the following C++ code: IntegrationCorneredGaussian integration_test ; IntegrationStatistics stats ; Pointset < D , double , Point > pts ; //We assume pts is filled stats . nbpts = pts . size (); //Can be done several times if we need to average over //several stochastic pointsets double analytical = 0 ; double integration = 0 ; integration_test . compute < D , double , Point > ( pts , integration , analytical ) stats . setAnalytical ( analytical ); stats . addValue ( integration ); stats . computeStatistics (); std :: cout << stats << std :: endl ;","title":"Execution"},{"location":"integration_cornered_gaussian/#results","text":"Stochastic sampler ./bin/integration/IntegrationCorneredGaussian_fromfile_2dd -i stratified_256.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 256 0.249767 1.78588e-05 0.240248 0.256679 0.25 1.61271e-05 10 \u2026 ./bin/integration/IntegrationCorneredGaussian_fromfile_2dd -i stratified_1024.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 1024 0.249748 7.42086e-07 0.248584 0.251039 0.25 7.31222e-07 10 \u2026 ./bin/integration/IntegrationCorneredGaussian_fromfile_2dd -i stratified_4096.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 4096 0.249878 7.96447e-08 0.249494 0.250237 0.25 8.66692e-08 10 \u2026 Deterministic sampler ./bin/integration/IntegrationCorneredGaussian_fromfile_2dd -i sobol_1024.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 1024 0.250991 0 0.250991 0.250991 0.25 9.82109e-07 1 ./bin/integration/IntegrationCorneredGaussian_fromfile_2dd -i sobol_4096.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 4096 0.250259 0 0.250259 0.250259 0.25 6.72357e-08 1","title":"Results"},{"location":"integration_gaussian/","text":"Integration IntegrationGaussian Files src/integration/IntegrationGaussian.hpp src/bin/integration/IntegrationGaussian_fromfile_2dd.cpp.cpp Description This test uses an input pointset to approximate the CDF of a Gaussian function using a Monte Carlo estimator. Note that due to our inability to find any analytical function to determine the area of a cropped gaussian, we devised independent tests for a centered uncropped gaussian and a 1/4 cropped gaussian (which both have exact analytical values) and a generic gaussian where the analytical value is estimated using a Monte Carlo estimator using 10e6 regular samples. This test exists only in 2D. License BSD, see IntegrationGaussian.hpp Execution Parameters: [HELP] --stddevx [double=0.15] Sets the x value for the standard deviation of the gaussian --meanx [double=0.5] Sets the x value for the mean of the gaussian --stddevy [double=0.15] Sets the y value for the standard deviation of the gaussian --meany [double=0.5] Sets the y value for the mean of the gaussian --outputfunc Outputs the integrated function in func.dat (plottable with gnuplot) --outputimg Outputs the integrated function in func.png -h [string] Displays this help message -i [string] The input pointsets -o [string] The output integration results -s [uint] The number of samples to read (if integrating from a sequence) --silent Silent mode --brute Output brute values instead of computing the statistics To integrate over a function using an input 2D point set, we can use the following client line command: ./bin/integration/IntegrationGaussian_fromfile_2dd -i toto.dat Or one can use the following C++ code: IntegrationGaussian integration_test ; IntegrationStatistics stats ; Pointset < D , double , Point > pts ; //We assume pts is filled stats . nbpts = pts . size (); //Can be done several times if we need to average over //several stochastic pointsets double analytical = 0 ; double integration = 0 ; integration_test . compute < D , double , Point > ( pts , integration , analytical ) stats . setAnalytical ( analytical ); stats . addValue ( integration ); stats . computeStatistics (); std :: cout << stats << std :: endl ; Results Stochastic sampler ./bin/integration/IntegrationGaussian_fromfile_2dd -i stratified_256.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 256 0.998641 0.000114815 0.978868 1.01693 0.998284 0.000103461 10 \u2026 ./bin/integration/IntegrationGaussian_fromfile_2dd -i stratified_1024.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 1024 0.998347 1.52336e-05 0.990475 1.00308 0.998284 1.37142e-05 10 \u2026 ./bin/integration/IntegrationGaussian_fromfile_2dd -i stratified_4096.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 4096 0.997984 9.59856e-07 0.996402 0.999474 0.998284 9.53883e-07 10 \u2026 Deterministic sampler ./bin/integration/IntegrationGaussian_fromfile_2dd -i sobol_1024.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 1024 0.998285 0 0.998285 0.998285 0.998284 6.1907e-13 1 ./bin/integration/IntegrationGaussian_fromfile_2dd -i sobol_4096.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 4096 0.998284 0 0.998284 0.998284 0.998284 1.52042e-13 1 Changing the gaussian parameters ./bin/integration/IntegrationGaussian_fromfile_2dd --meanx 0.25 --meany 0.75 --stddevx 0.1 --stddevy 0.1 -i sobol_1024.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 1024 0.987861 0 0.987861 0.987861 0.987619 5.82659e-08 1 ./bin/integration/IntegrationGaussian_fromfile_2dd --meanx 0.35 --meany 0.45 --stddevx 0.05 --stddevy 0.1 -i sobol_1024.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 1024 0.998168 0 0.998168 0.998168 0.999997 3.34345e-06 1","title":"Gaussian"},{"location":"integration_gaussian/#integration-integrationgaussian","text":"","title":"Integration IntegrationGaussian"},{"location":"integration_gaussian/#files","text":"src/integration/IntegrationGaussian.hpp src/bin/integration/IntegrationGaussian_fromfile_2dd.cpp.cpp","title":"Files"},{"location":"integration_gaussian/#description","text":"This test uses an input pointset to approximate the CDF of a Gaussian function using a Monte Carlo estimator. Note that due to our inability to find any analytical function to determine the area of a cropped gaussian, we devised independent tests for a centered uncropped gaussian and a 1/4 cropped gaussian (which both have exact analytical values) and a generic gaussian where the analytical value is estimated using a Monte Carlo estimator using 10e6 regular samples. This test exists only in 2D.","title":"Description"},{"location":"integration_gaussian/#license","text":"BSD, see IntegrationGaussian.hpp","title":"License"},{"location":"integration_gaussian/#execution","text":"Parameters: [HELP] --stddevx [double=0.15] Sets the x value for the standard deviation of the gaussian --meanx [double=0.5] Sets the x value for the mean of the gaussian --stddevy [double=0.15] Sets the y value for the standard deviation of the gaussian --meany [double=0.5] Sets the y value for the mean of the gaussian --outputfunc Outputs the integrated function in func.dat (plottable with gnuplot) --outputimg Outputs the integrated function in func.png -h [string] Displays this help message -i [string] The input pointsets -o [string] The output integration results -s [uint] The number of samples to read (if integrating from a sequence) --silent Silent mode --brute Output brute values instead of computing the statistics To integrate over a function using an input 2D point set, we can use the following client line command: ./bin/integration/IntegrationGaussian_fromfile_2dd -i toto.dat Or one can use the following C++ code: IntegrationGaussian integration_test ; IntegrationStatistics stats ; Pointset < D , double , Point > pts ; //We assume pts is filled stats . nbpts = pts . size (); //Can be done several times if we need to average over //several stochastic pointsets double analytical = 0 ; double integration = 0 ; integration_test . compute < D , double , Point > ( pts , integration , analytical ) stats . setAnalytical ( analytical ); stats . addValue ( integration ); stats . computeStatistics (); std :: cout << stats << std :: endl ;","title":"Execution"},{"location":"integration_gaussian/#results","text":"Stochastic sampler ./bin/integration/IntegrationGaussian_fromfile_2dd -i stratified_256.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 256 0.998641 0.000114815 0.978868 1.01693 0.998284 0.000103461 10 \u2026 ./bin/integration/IntegrationGaussian_fromfile_2dd -i stratified_1024.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 1024 0.998347 1.52336e-05 0.990475 1.00308 0.998284 1.37142e-05 10 \u2026 ./bin/integration/IntegrationGaussian_fromfile_2dd -i stratified_4096.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 4096 0.997984 9.59856e-07 0.996402 0.999474 0.998284 9.53883e-07 10 \u2026 Deterministic sampler ./bin/integration/IntegrationGaussian_fromfile_2dd -i sobol_1024.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 1024 0.998285 0 0.998285 0.998285 0.998284 6.1907e-13 1 ./bin/integration/IntegrationGaussian_fromfile_2dd -i sobol_4096.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 4096 0.998284 0 0.998284 0.998284 0.998284 1.52042e-13 1 Changing the gaussian parameters ./bin/integration/IntegrationGaussian_fromfile_2dd --meanx 0.25 --meany 0.75 --stddevx 0.1 --stddevy 0.1 -i sobol_1024.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 1024 0.987861 0 0.987861 0.987861 0.987619 5.82659e-08 1 ./bin/integration/IntegrationGaussian_fromfile_2dd --meanx 0.35 --meany 0.45 --stddevx 0.05 --stddevy 0.1 -i sobol_1024.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 1024 0.998168 0 0.998168 0.998168 0.999997 3.34345e-06 1","title":"Results"},{"location":"integration_image/","text":"Integration Image Files src/integration/IntegrationImage.hpp src/bin/integration/IntegrationImage_fromfile_2dd.cpp.cpp Description This test uses an input pointset to approximate the integration of an image using a Monte Carlo estimator. Note that since there are no analytical function for this integration, we define this analytical function as the sum of the values of all pixels of the image. We usually integrate over HDR images. This test exists only in 2D. License BSD, see IntegrationImage.hpp Execution Parameters: [HELP] --image [string] The image to integrate -h [string] Displays this help message -i [string] The input pointsets -o [string] The output integration results -s [uint] The number of samples to read (if integrating from a sequence) --silent Silent mode --brute Output brute values instead of computing the statistics To integrate over a function using an input 2D point set, we can use the following client line command: ./bin/integration/IntegrationImage2D_fromfile_2dd --image ../../data/HDR/HDRimage1600x1600_017.exr -i toto.dat Or one can use the following C++ code: IntegrationImage integration_test ; IntegrationStatistics stats ; Pointset < D , double , Point > pts ; integration_test . setImage ( \"../../data/HDR/HDRimage1600x1600_017.exr\" ); //We assume pts is filled stats . nbpts = pts . size (); //Can be done several times if we need to average over //several stochastic pointsets double analytical = 0 ; double integration = 0 ; integration_test . compute < D , double , Point > ( pts , integration , analytical ) stats . setAnalytical ( analytical ); stats . addValue ( integration ); stats . computeStatistics (); std :: cout << stats << std :: endl ; Results Stochastic sampler ./bin/integration/IntegrationImage2D_fromfile_2dd --image ../../data/HDR/HDRimage1600x1600_017.exr -i stratified_256.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 256 0.00526645 5.08625e-08 0.00490972 0.00564206 0.00532679 4.94174e-08 10 \u2026 ./bin/integration/IntegrationImage2D_fromfile_2dd --image ../../data/HDR/HDRimage1600x1600_017.exr -i stratified_1024.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 1024 0.00533107 7.88106e-09 0.00521723 0.0054546 0.00532679 7.1113e-09 10 \u2026 ./bin/integration/IntegrationImage2D_fromfile_2dd --image ../../data/HDR/HDRimage1600x1600_017.exr -i stratified_4096.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 4096 0.00532906 7.15467e-10 0.00527126 0.00536509 0.00532679 6.49065e-10 10 \u2026 Deterministic sampler ./bin/integration/IntegrationImage2D_fromfile_2dd --image ../../data/HDR/HDRimage1600x1600_017.exr -i sobol_1024.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 1024 0.00531459 0 0.00531459 0.00531459 0.00532679 1.48854e-10 1 ./bin/integration/IntegrationImage2D_fromfile_2dd --image ../../data/HDR/HDRimage1600x1600_017.exr -i sobol_4096.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 4096 0.00531362 0 0.00531362 0.00531362 0.00532679 1.73295e-10 1","title":"Image"},{"location":"integration_image/#integration-image","text":"","title":"Integration Image"},{"location":"integration_image/#files","text":"src/integration/IntegrationImage.hpp src/bin/integration/IntegrationImage_fromfile_2dd.cpp.cpp","title":"Files"},{"location":"integration_image/#description","text":"This test uses an input pointset to approximate the integration of an image using a Monte Carlo estimator. Note that since there are no analytical function for this integration, we define this analytical function as the sum of the values of all pixels of the image. We usually integrate over HDR images. This test exists only in 2D.","title":"Description"},{"location":"integration_image/#license","text":"BSD, see IntegrationImage.hpp","title":"License"},{"location":"integration_image/#execution","text":"Parameters: [HELP] --image [string] The image to integrate -h [string] Displays this help message -i [string] The input pointsets -o [string] The output integration results -s [uint] The number of samples to read (if integrating from a sequence) --silent Silent mode --brute Output brute values instead of computing the statistics To integrate over a function using an input 2D point set, we can use the following client line command: ./bin/integration/IntegrationImage2D_fromfile_2dd --image ../../data/HDR/HDRimage1600x1600_017.exr -i toto.dat Or one can use the following C++ code: IntegrationImage integration_test ; IntegrationStatistics stats ; Pointset < D , double , Point > pts ; integration_test . setImage ( \"../../data/HDR/HDRimage1600x1600_017.exr\" ); //We assume pts is filled stats . nbpts = pts . size (); //Can be done several times if we need to average over //several stochastic pointsets double analytical = 0 ; double integration = 0 ; integration_test . compute < D , double , Point > ( pts , integration , analytical ) stats . setAnalytical ( analytical ); stats . addValue ( integration ); stats . computeStatistics (); std :: cout << stats << std :: endl ;","title":"Execution"},{"location":"integration_image/#results","text":"Stochastic sampler ./bin/integration/IntegrationImage2D_fromfile_2dd --image ../../data/HDR/HDRimage1600x1600_017.exr -i stratified_256.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 256 0.00526645 5.08625e-08 0.00490972 0.00564206 0.00532679 4.94174e-08 10 \u2026 ./bin/integration/IntegrationImage2D_fromfile_2dd --image ../../data/HDR/HDRimage1600x1600_017.exr -i stratified_1024.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 1024 0.00533107 7.88106e-09 0.00521723 0.0054546 0.00532679 7.1113e-09 10 \u2026 ./bin/integration/IntegrationImage2D_fromfile_2dd --image ../../data/HDR/HDRimage1600x1600_017.exr -i stratified_4096.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 4096 0.00532906 7.15467e-10 0.00527126 0.00536509 0.00532679 6.49065e-10 10 \u2026 Deterministic sampler ./bin/integration/IntegrationImage2D_fromfile_2dd --image ../../data/HDR/HDRimage1600x1600_017.exr -i sobol_1024.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 1024 0.00531459 0 0.00531459 0.00531459 0.00532679 1.48854e-10 1 ./bin/integration/IntegrationImage2D_fromfile_2dd --image ../../data/HDR/HDRimage1600x1600_017.exr -i sobol_4096.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 4096 0.00531362 0 0.00531362 0.00531362 0.00532679 1.73295e-10 1","title":"Results"},{"location":"integration_n-Sphere/","text":"Integration n-Sphere Files src/integration/IntegrationNSphere.hpp src/bin/integration/IntegrationNSphere_fromfile_*d*.cpp.cpp Description This test uses an input pointset to approximate the area of a n dimensional sphere using a Monte Carlo estimator. Note that the sphere is centered at 0^D (points are scaled to [-0.5, 0.5]^D), has a value of 1 inside, and 0 outside. This test is shown here in 2D but it exists also in 3D and 4D. License BSD, see IntegrationNSphere.hpp Execution Parameters: [HELP] --radius [double=0.25] Sets the radius of the n_sphere. Must be in ]0, 0.5[ --outputfunc Outputs the integrated function in func.dat (plottable with gnuplot) --outputimg Outputs the integrated function in func.png -h [string] Displays this help message -i [string] The input pointsets -o [string] The output integration results -s [uint] The number of samples to read (if integrating from a sequence) --silent Silent mode --brute Output brute values instead of computing the statistics ``` To integrate over a function using an input 2D point set, we can use the following client line command: ./bin/integration/IntegrationNSphere_fromfile_2dd -i toto.dat Or one can use the following C++ code: ``` cpp IntegrationNSphere integration_test; IntegrationStatistics stats; Pointset< D, double, Point > pts; //We assume pts is filled stats.nbpts = pts.size(); //Can be done several times if we need to average over //several stochastic pointsets double analytical = 0; double integration = 0; integration_test.compute< D, double, Point >(pts, integration, analytical) stats.setAnalytical(analytical); stats.addValue(integration); stats.computeStatistics(); std::cout << stats << std::endl; Results Stochastic sampler ./bin/integration/IntegrationNSphere_fromfile_2dd -i stratified_256.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 256 0.197266 2.11928e-05 0.191406 0.203125 0.19635 1.99127e-05 10 \u2026 ./bin/integration/IntegrationNSphere_fromfile_2dd -i stratified_1024.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 1024 0.198926 1.0607e-05 0.194336 0.205078 0.19635 1.61833e-05 10 \u2026 ./bin/integration/IntegrationNSphere_fromfile_2dd -i stratified_4096.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 4096 0.196167 1.02321e-06 0.194336 0.197998 0.19635 9.54216e-07 10 \u2026 Deterministic sampler ./bin/integration/IntegrationNSphere_fromfile_2dd -i sobol_1024.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 1024 0.203125 0 0.203125 0.203125 0.19635 4.59068e-05 1 ./bin/integration/IntegrationNSphere_fromfile_2dd -i sobol_4096.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 4096 0.196289 0 0.196289 0.196289 0.19635 3.65763e-09 1 Changing Radius ./bin/integration/IntegrationNSphere_fromfile_2dd --radius 0.1 -i sobol_1024.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 1024 0.0332031 0 0.0332031 0.0332031 0.0314159 3.19408e-06 1 ./bin/integration/IntegrationNSphere_fromfile_2dd --radius 0.4 -i sobol_1024.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 1024 0.50293 0 0.50293 0.50293 0.502655 7.55496e-08 1","title":"NSpheres"},{"location":"integration_n-Sphere/#integration-n-sphere","text":"","title":"Integration n-Sphere"},{"location":"integration_n-Sphere/#files","text":"src/integration/IntegrationNSphere.hpp src/bin/integration/IntegrationNSphere_fromfile_*d*.cpp.cpp","title":"Files"},{"location":"integration_n-Sphere/#description","text":"This test uses an input pointset to approximate the area of a n dimensional sphere using a Monte Carlo estimator. Note that the sphere is centered at 0^D (points are scaled to [-0.5, 0.5]^D), has a value of 1 inside, and 0 outside. This test is shown here in 2D but it exists also in 3D and 4D.","title":"Description"},{"location":"integration_n-Sphere/#license","text":"BSD, see IntegrationNSphere.hpp","title":"License"},{"location":"integration_n-Sphere/#execution","text":"Parameters: [HELP] --radius [double=0.25] Sets the radius of the n_sphere. Must be in ]0, 0.5[ --outputfunc Outputs the integrated function in func.dat (plottable with gnuplot) --outputimg Outputs the integrated function in func.png -h [string] Displays this help message -i [string] The input pointsets -o [string] The output integration results -s [uint] The number of samples to read (if integrating from a sequence) --silent Silent mode --brute Output brute values instead of computing the statistics ``` To integrate over a function using an input 2D point set, we can use the following client line command: ./bin/integration/IntegrationNSphere_fromfile_2dd -i toto.dat Or one can use the following C++ code: ``` cpp IntegrationNSphere integration_test; IntegrationStatistics stats; Pointset< D, double, Point > pts; //We assume pts is filled stats.nbpts = pts.size(); //Can be done several times if we need to average over //several stochastic pointsets double analytical = 0; double integration = 0; integration_test.compute< D, double, Point >(pts, integration, analytical) stats.setAnalytical(analytical); stats.addValue(integration); stats.computeStatistics(); std::cout << stats << std::endl;","title":"Execution"},{"location":"integration_n-Sphere/#results","text":"Stochastic sampler ./bin/integration/IntegrationNSphere_fromfile_2dd -i stratified_256.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 256 0.197266 2.11928e-05 0.191406 0.203125 0.19635 1.99127e-05 10 \u2026 ./bin/integration/IntegrationNSphere_fromfile_2dd -i stratified_1024.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 1024 0.198926 1.0607e-05 0.194336 0.205078 0.19635 1.61833e-05 10 \u2026 ./bin/integration/IntegrationNSphere_fromfile_2dd -i stratified_4096.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 4096 0.196167 1.02321e-06 0.194336 0.197998 0.19635 9.54216e-07 10 \u2026 Deterministic sampler ./bin/integration/IntegrationNSphere_fromfile_2dd -i sobol_1024.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 1024 0.203125 0 0.203125 0.203125 0.19635 4.59068e-05 1 ./bin/integration/IntegrationNSphere_fromfile_2dd -i sobol_4096.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 4096 0.196289 0 0.196289 0.196289 0.19635 3.65763e-09 1 Changing Radius ./bin/integration/IntegrationNSphere_fromfile_2dd --radius 0.1 -i sobol_1024.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 1024 0.0332031 0 0.0332031 0.0332031 0.0314159 3.19408e-06 1 ./bin/integration/IntegrationNSphere_fromfile_2dd --radius 0.4 -i sobol_1024.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 1024 0.50293 0 0.50293 0.50293 0.502655 7.55496e-08 1","title":"Results"},{"location":"integration_triangle_arrangement/","text":"Integration Triangle Arrangement Files src/integration/IntegrationTriangleArrangement.hpp src/integration/arrangement/TriangleArrangement.hpp src/integration/arrangement/TrianglesRandom.hpp src/bin/integration/IntegrationTriangleArrangement_fromfile_2dd.cpp Description To palliate the absence of analytical expression for natural images, we instead try to integrate analytical arrangements of boxes or triangles. Such arrangement present analytical expression for their integrand and are therefore a better reference when testing the behavior of a sampler when used to approximate an integrand using a Monte Carlo estimator. Note that this test is not yet finished. Due to numerical imprecisions (?), we can\u2019t generate too many triangles and boxes within the arrangement. Furthermore, the Fourier spectrum of the arrangement is not yet controllable. However, this second issue might be solved by distributing shapes following colored noise distributions (green noise, pink noise, blue noise). as each color of noise seems to affect a particular range of frequencies. Note This tool requires the CGAL library. You would need also to set cmake .. -DUSE_CGAL=true when generating the project. License BSD, see IntegrationTriangleArrangement.hpp Execution Parameters: [HELP] -h [string] Displays this help message -i [string] The input pointsets -o [string] The output integration results -s [uint] The number of samples to read (if integrating from a sequence) --silent Silent mode --brute Output brute values instead of computing the statistics -r [string] Rasterized output To integrate over a function using an input 2D point set, we can use the following client line command: ./bin/integration/IntegrationTriangleArrangement_fromfile_2dd -i toto.dat Or one can use the following C++ code: IntegrationTriangleArrangement integration_test ; IntegrationStatistics stats ; Pointset < D , double , Point > pts ; //We assume pts is filled stats . nbpts = pts . size (); //Can be done several times if we need to average over //several stochastic pointsets double analytical = 0 ; double integration = 0 ; integration_test . compute < D , double , Point > ( pts , integration , analytical ) stats . setAnalytical ( analytical ); stats . addValue ( integration ); stats . computeStatistics (); std :: cout << stats << std :: endl ; Results Stochastic sampler ./bin/integration/IntegrationTriangleArrangement_fromfile_2dd -i stratified_256.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 256 132.652 149.531 114.164 143.926 130.15 140.841 10 \u2026 ./bin/integration/IntegrationTriangleArrangement_fromfile_2dd -i stratified_1024.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 1024 130.225 20.2556 122.274 138.928 130.15 18.2358 10 \u2026 ./bin/integration/IntegrationTriangleArrangement_fromfile_2dd -i stratified_4096.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 4096 130.193 3.12017 128.694 134.533 130.15 2.81005 10 \u2026 Deterministic sampler ./bin/integration/IntegrationTriangleArrangement_fromfile_2dd -i sobol_1024.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 1024 131.031 0 131.031 131.031 130.15 0.77707 1 ./bin/integration/IntegrationTriangleArrangement_fromfile_2dd -i sobol_4096.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 4096 133.135 0 133.135 133.135 130.15 8.90896 1","title":"Triangle arrangement"},{"location":"integration_triangle_arrangement/#integration-triangle-arrangement","text":"","title":"Integration Triangle Arrangement"},{"location":"integration_triangle_arrangement/#files","text":"src/integration/IntegrationTriangleArrangement.hpp src/integration/arrangement/TriangleArrangement.hpp src/integration/arrangement/TrianglesRandom.hpp src/bin/integration/IntegrationTriangleArrangement_fromfile_2dd.cpp","title":"Files"},{"location":"integration_triangle_arrangement/#description","text":"To palliate the absence of analytical expression for natural images, we instead try to integrate analytical arrangements of boxes or triangles. Such arrangement present analytical expression for their integrand and are therefore a better reference when testing the behavior of a sampler when used to approximate an integrand using a Monte Carlo estimator. Note that this test is not yet finished. Due to numerical imprecisions (?), we can\u2019t generate too many triangles and boxes within the arrangement. Furthermore, the Fourier spectrum of the arrangement is not yet controllable. However, this second issue might be solved by distributing shapes following colored noise distributions (green noise, pink noise, blue noise). as each color of noise seems to affect a particular range of frequencies. Note This tool requires the CGAL library. You would need also to set cmake .. -DUSE_CGAL=true when generating the project.","title":"Description"},{"location":"integration_triangle_arrangement/#license","text":"BSD, see IntegrationTriangleArrangement.hpp","title":"License"},{"location":"integration_triangle_arrangement/#execution","text":"Parameters: [HELP] -h [string] Displays this help message -i [string] The input pointsets -o [string] The output integration results -s [uint] The number of samples to read (if integrating from a sequence) --silent Silent mode --brute Output brute values instead of computing the statistics -r [string] Rasterized output To integrate over a function using an input 2D point set, we can use the following client line command: ./bin/integration/IntegrationTriangleArrangement_fromfile_2dd -i toto.dat Or one can use the following C++ code: IntegrationTriangleArrangement integration_test ; IntegrationStatistics stats ; Pointset < D , double , Point > pts ; //We assume pts is filled stats . nbpts = pts . size (); //Can be done several times if we need to average over //several stochastic pointsets double analytical = 0 ; double integration = 0 ; integration_test . compute < D , double , Point > ( pts , integration , analytical ) stats . setAnalytical ( analytical ); stats . addValue ( integration ); stats . computeStatistics (); std :: cout << stats << std :: endl ;","title":"Execution"},{"location":"integration_triangle_arrangement/#results","text":"Stochastic sampler ./bin/integration/IntegrationTriangleArrangement_fromfile_2dd -i stratified_256.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 256 132.652 149.531 114.164 143.926 130.15 140.841 10 \u2026 ./bin/integration/IntegrationTriangleArrangement_fromfile_2dd -i stratified_1024.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 1024 130.225 20.2556 122.274 138.928 130.15 18.2358 10 \u2026 ./bin/integration/IntegrationTriangleArrangement_fromfile_2dd -i stratified_4096.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 4096 130.193 3.12017 128.694 134.533 130.15 2.81005 10 \u2026 Deterministic sampler ./bin/integration/IntegrationTriangleArrangement_fromfile_2dd -i sobol_1024.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 1024 131.031 0 131.031 131.031 130.15 0.77707 1 ./bin/integration/IntegrationTriangleArrangement_fromfile_2dd -i sobol_4096.dat #Nbpts #Mean #Var #Min #Max #Analytical #MSE #NbPtsets 4096 133.135 0 133.135 133.135 130.15 8.90896 1","title":"Results"},{"location":"io_bin/","text":"File format .bin Files src/io/fileIO.hpp src/io/fileIO_model.hpp src/io/fileIO_bin.hpp Description UnicornTK relies on the extension of the input file to determine its type. When the extension is .bin , the pointsets are stored in binary mode, without any header. It is much more efficient than ascii based format like .dat or .edat , and is usually less memory expensive.","title":"File format .bin"},{"location":"io_bin/#file-format-bin","text":"","title":"File format .bin"},{"location":"io_bin/#files","text":"src/io/fileIO.hpp src/io/fileIO_model.hpp src/io/fileIO_bin.hpp","title":"Files"},{"location":"io_bin/#description","text":"UnicornTK relies on the extension of the input file to determine its type. When the extension is .bin , the pointsets are stored in binary mode, without any header. It is much more efficient than ascii based format like .dat or .edat , and is usually less memory expensive.","title":"Description"},{"location":"io_dat/","text":"File format .dat Files src/io/fileIO.hpp src/io/fileIO_model.hpp src/io/fileIO_dat.hpp Description UnicornTK relies on the extension of the input file to determine its type. When the extension is .dat, the pointsets are stored in ASCII mode, without any header. It separates pointsets using \u201c#\u201d. Examples Pointset 2D, with integer coordinates: 0 0 8 9 4 18 12 3 2 12 10 21 6 6 14 15 1 24 9 1 5 10 13 19 3 4 11 13 7 22 15 7 Several pointsets 3D, with floating point coordinates: 0.028783979133885 0.155514565332680 0.960157398590855 0.312483705652990 0.218556602070703 0.384967410560923 0.673679314012099 0.457069308836262 0.125204502866884 0.031104644069240 0.744467481911291 0.151364350493849 0.780586515967871 0.647713547723301 0.074998346640495 0.988180965182414 0.776412255544311 0.278134082275940 0.983786377586375 0.678964280914274 0.202230252139790 0.979205362726749 0.478744334187066 0.508492128110605 0.071264026237480 0.081133399876098 0.114889761226925 0.707450484556018 0.673803976428184 0.768690652160135 0.978489566822185 0.491386972715004 0.802415643539842 0.209128453212122 0.559688900494876 0.535038666691407 0.795027539086302 0.867286721446385 0.009843063077387 0.022699957020278 0.192193951502488 0.989124133714737 0.733347095487022 0.055634353322823 0.477618701401543 0.270563270261177 0.253405835538499 0.244658759386432 # 0.064694803456006 0.113265726508867 0.716461862371411 0.700323686399572 0.262854798525305 0.312922639146662 0.737317744814166 0.244726494011638 0.160374866835860 0.775333373056569 0.278546509164978 0.554354619596702 0.690523887912399 0.468639145481549 0.485897624978306 0.253916406830288 0.676244719577079 0.781629592362239 0.512115267690298 0.227197893016785 0.797832129941748 0.808880204057526 0.302567068790683 0.670762139295871 0.121818090351722 0.603383327741964 0.627563637128929 0.419228645139194 0.636057091559297 0.647391159238152 0.110336893496648 0.254953653610999 0.201824090024881 0.314142002564422 0.821459031855096 0.298805406386686 0.003854810261134 0.699553342233308 0.648625409381610 0.406942344365395 0.550702066754620 0.131240437536324 0.208173566313501 0.073366599174535 0.629220015283027 0.553746611474489 0.286626003982179 0.075691768917183","title":"File format .dat"},{"location":"io_dat/#file-format-dat","text":"","title":"File format .dat"},{"location":"io_dat/#files","text":"src/io/fileIO.hpp src/io/fileIO_model.hpp src/io/fileIO_dat.hpp","title":"Files"},{"location":"io_dat/#description","text":"UnicornTK relies on the extension of the input file to determine its type. When the extension is .dat, the pointsets are stored in ASCII mode, without any header. It separates pointsets using \u201c#\u201d.","title":"Description"},{"location":"io_dat/#examples","text":"Pointset 2D, with integer coordinates: 0 0 8 9 4 18 12 3 2 12 10 21 6 6 14 15 1 24 9 1 5 10 13 19 3 4 11 13 7 22 15 7 Several pointsets 3D, with floating point coordinates: 0.028783979133885 0.155514565332680 0.960157398590855 0.312483705652990 0.218556602070703 0.384967410560923 0.673679314012099 0.457069308836262 0.125204502866884 0.031104644069240 0.744467481911291 0.151364350493849 0.780586515967871 0.647713547723301 0.074998346640495 0.988180965182414 0.776412255544311 0.278134082275940 0.983786377586375 0.678964280914274 0.202230252139790 0.979205362726749 0.478744334187066 0.508492128110605 0.071264026237480 0.081133399876098 0.114889761226925 0.707450484556018 0.673803976428184 0.768690652160135 0.978489566822185 0.491386972715004 0.802415643539842 0.209128453212122 0.559688900494876 0.535038666691407 0.795027539086302 0.867286721446385 0.009843063077387 0.022699957020278 0.192193951502488 0.989124133714737 0.733347095487022 0.055634353322823 0.477618701401543 0.270563270261177 0.253405835538499 0.244658759386432 # 0.064694803456006 0.113265726508867 0.716461862371411 0.700323686399572 0.262854798525305 0.312922639146662 0.737317744814166 0.244726494011638 0.160374866835860 0.775333373056569 0.278546509164978 0.554354619596702 0.690523887912399 0.468639145481549 0.485897624978306 0.253916406830288 0.676244719577079 0.781629592362239 0.512115267690298 0.227197893016785 0.797832129941748 0.808880204057526 0.302567068790683 0.670762139295871 0.121818090351722 0.603383327741964 0.627563637128929 0.419228645139194 0.636057091559297 0.647391159238152 0.110336893496648 0.254953653610999 0.201824090024881 0.314142002564422 0.821459031855096 0.298805406386686 0.003854810261134 0.699553342233308 0.648625409381610 0.406942344365395 0.550702066754620 0.131240437536324 0.208173566313501 0.073366599174535 0.629220015283027 0.553746611474489 0.286626003982179 0.075691768917183","title":"Examples"},{"location":"io_ebin/","text":"File format .ebin Files src/io/fileIO.hpp src/io/fileIO_model.hpp src/io/fileIO_ebin.hpp Description UnicornTK relies on the extension of the input file to determine its type. When the extension is .ebin , the pointsets are stored in binary mode, with a header containing the extend of the pointset domain and the toricity of the pointset. It is much more efficient than ascii based format like .dat or .edat , and is usually less memory expensive.","title":"File format .ebin"},{"location":"io_ebin/#file-format-ebin","text":"","title":"File format .ebin"},{"location":"io_ebin/#files","text":"src/io/fileIO.hpp src/io/fileIO_model.hpp src/io/fileIO_ebin.hpp","title":"Files"},{"location":"io_ebin/#description","text":"UnicornTK relies on the extension of the input file to determine its type. When the extension is .ebin , the pointsets are stored in binary mode, with a header containing the extend of the pointset domain and the toricity of the pointset. It is much more efficient than ascii based format like .dat or .edat , and is usually less memory expensive.","title":"Description"},{"location":"io_edat/","text":"File format .edat Files src/io/fileIO.hpp src/io/fileIO_model.hpp src/io/fileIO_edat.hpp Description UnicornTK relies on the extension of the input file to determine its type. When the extension is .edat , the pointsets are stored in ASCII mode, with a 3 line header containing the extend of the pointset domain and the toricity of the pointset. The first line is the minimal point of the domain, the second line is the maximal point and the third line contains a boolean indicating is the pointset is toric or not It separates pointsets using \u201c#\u201d. Examples Pointset 2D, Toric, in domain [0,1]^3 [0,1]^3 , with integer coordinates: 0 0 1024 2187 1 0 0 512 729 256 1458 768 243 128 972 640 1701 384 486 896 1215 64 1944 576 81 320 810 832 1539 192 324 704 1053 448 1782 960 567 32 1296 544 2025 288 162 800 891 160 1620 672 405 416 1134 928 1863 96 648 Several pointsets 3D, Toric, in domain [0,1]^3 [0,1]^3 , with floating point coordinates: 0.000000000000000 0.000000000000000 0.000000000000000 1.000000000000000 1.000000000000000 1.000000000000000 1 0.050395372335425 0.605445716671051 0.404234371009337 0.825739547336879 0.019014228372605 0.571619643962853 0.251084789226550 0.796739092282192 0.662392276959119 0.076733451587319 0.966740387484138 0.104033727921553 0.022851851774112 0.541269098301714 0.274100657150638 0.836165956649037 0.710473378354328 0.218262058035066 0.734431378481544 0.045624867092265 0.108525469691615 0.424232415953705 0.622989150374892 0.445836456596348 0.459817434535319 0.149720273248321 0.263248428763647 0.492075960732083 0.549053552688345 0.021870193542417 0.331534335234094 0.343634019220163 0.221821374311536 0.398141971416339 0.458952383943590 0.978517358419140 0.269279661418237 0.511562038332122 0.016162883494087 0.258357287444723 0.187212941280383 0.399687562696563 0.796217287843166 0.147599688299838 0.400614753225961 0.748264057735974 0.041631821552671 0.061114694238900 # 0.000000000000000 0.000000000000000 0.000000000000000 1.000000000000000 1.000000000000000 1.000000000000000 1 0.728055556474266 0.560123025104432 0.385942792609786 0.199736131401671 0.196849285437923 0.846230597897952 0.965195278163346 0.820035925093115 0.776832124632046 0.207031543414814 0.707106014878281 0.422963624918592 0.437438748645931 0.934516076914621 0.731540281030242 0.884149564868805 0.817359755006004 0.868729761072604 0.340246866303554 0.478473960766213 0.475246819778170 0.919041518335939 0.328492126969735 0.889999115348328 0.629857444816701 0.050157970760520 0.017919836337194 0.936117153134224 0.322178287972272 0.747246075828384 0.260712328427637 0.595219216448073 0.609722221644996 0.703291282920002 0.980232460419701 0.416594642544304 0.947554823464610 0.746043482969060 0.298958397540021 0.861714192401086 0.825613557320464 0.466442995114821 0.609747354781662 0.819148976779345 0.878929865983997 0.334699008226092 0.987974778280588 0.963871809412695","title":"File format .edat"},{"location":"io_edat/#file-format-edat","text":"","title":"File format .edat"},{"location":"io_edat/#files","text":"src/io/fileIO.hpp src/io/fileIO_model.hpp src/io/fileIO_edat.hpp","title":"Files"},{"location":"io_edat/#description","text":"UnicornTK relies on the extension of the input file to determine its type. When the extension is .edat , the pointsets are stored in ASCII mode, with a 3 line header containing the extend of the pointset domain and the toricity of the pointset. The first line is the minimal point of the domain, the second line is the maximal point and the third line contains a boolean indicating is the pointset is toric or not It separates pointsets using \u201c#\u201d.","title":"Description"},{"location":"io_edat/#examples","text":"Pointset 2D, Toric, in domain [0,1]^3 [0,1]^3 , with integer coordinates: 0 0 1024 2187 1 0 0 512 729 256 1458 768 243 128 972 640 1701 384 486 896 1215 64 1944 576 81 320 810 832 1539 192 324 704 1053 448 1782 960 567 32 1296 544 2025 288 162 800 891 160 1620 672 405 416 1134 928 1863 96 648 Several pointsets 3D, Toric, in domain [0,1]^3 [0,1]^3 , with floating point coordinates: 0.000000000000000 0.000000000000000 0.000000000000000 1.000000000000000 1.000000000000000 1.000000000000000 1 0.050395372335425 0.605445716671051 0.404234371009337 0.825739547336879 0.019014228372605 0.571619643962853 0.251084789226550 0.796739092282192 0.662392276959119 0.076733451587319 0.966740387484138 0.104033727921553 0.022851851774112 0.541269098301714 0.274100657150638 0.836165956649037 0.710473378354328 0.218262058035066 0.734431378481544 0.045624867092265 0.108525469691615 0.424232415953705 0.622989150374892 0.445836456596348 0.459817434535319 0.149720273248321 0.263248428763647 0.492075960732083 0.549053552688345 0.021870193542417 0.331534335234094 0.343634019220163 0.221821374311536 0.398141971416339 0.458952383943590 0.978517358419140 0.269279661418237 0.511562038332122 0.016162883494087 0.258357287444723 0.187212941280383 0.399687562696563 0.796217287843166 0.147599688299838 0.400614753225961 0.748264057735974 0.041631821552671 0.061114694238900 # 0.000000000000000 0.000000000000000 0.000000000000000 1.000000000000000 1.000000000000000 1.000000000000000 1 0.728055556474266 0.560123025104432 0.385942792609786 0.199736131401671 0.196849285437923 0.846230597897952 0.965195278163346 0.820035925093115 0.776832124632046 0.207031543414814 0.707106014878281 0.422963624918592 0.437438748645931 0.934516076914621 0.731540281030242 0.884149564868805 0.817359755006004 0.868729761072604 0.340246866303554 0.478473960766213 0.475246819778170 0.919041518335939 0.328492126969735 0.889999115348328 0.629857444816701 0.050157970760520 0.017919836337194 0.936117153134224 0.322178287972272 0.747246075828384 0.260712328427637 0.595219216448073 0.609722221644996 0.703291282920002 0.980232460419701 0.416594642544304 0.947554823464610 0.746043482969060 0.298958397540021 0.861714192401086 0.825613557320464 0.466442995114821 0.609747354781662 0.819148976779345 0.878929865983997 0.334699008226092 0.987974778280588 0.963871809412695","title":"Examples"},{"location":"io_format/","text":"ASCII output .dat .edat Binary output .bin .ebin Graphic output .ps .tex (tikz)","title":"I/O formats"},{"location":"io_ps/","text":"File format .ps Files src/io/imageIO.hpp src/io/imageIO_model.hpp src/io/imageIO_ps.hpp Description UnicornTK relies on the extension of the input file to determine its type. When the extension is .ps , the pointset is drawn into a postscript file. Examples Input pointset Output .ps file Image sobol_128.edat sobol_128.ps stratified_25.dat stratified_25.ps toric_bnot_50.dat toric_bnot_50.ps","title":"File format .ps"},{"location":"io_ps/#file-format-ps","text":"","title":"File format .ps"},{"location":"io_ps/#files","text":"src/io/imageIO.hpp src/io/imageIO_model.hpp src/io/imageIO_ps.hpp","title":"Files"},{"location":"io_ps/#description","text":"UnicornTK relies on the extension of the input file to determine its type. When the extension is .ps , the pointset is drawn into a postscript file.","title":"Description"},{"location":"io_ps/#examples","text":"Input pointset Output .ps file Image sobol_128.edat sobol_128.ps stratified_25.dat stratified_25.ps toric_bnot_50.dat toric_bnot_50.ps","title":"Examples"},{"location":"io_tikz/","text":"File format .tex Files src/io/imageIO.hpp src/io/imageIO\\_model.hpp src/io/imageIO\\_tikz.hpp Description UnicornTK relies on the extension of the input file to determine its type. When the extension is .tex, the pointset is drawn as a tikz figure in a .tex file. This file can be compiled using any latex compiler you want to generate a .pdf image. Examples Input pointset Output .tex file Image sobol_128.edat sobol_128.tex stratified_25.dat stratified_25.tex toric_bnot_50.dat toric_bnot_50.tex","title":"File format .tex"},{"location":"io_tikz/#file-format-tex","text":"","title":"File format .tex"},{"location":"io_tikz/#files","text":"src/io/imageIO.hpp src/io/imageIO\\_model.hpp src/io/imageIO\\_tikz.hpp","title":"Files"},{"location":"io_tikz/#description","text":"UnicornTK relies on the extension of the input file to determine its type. When the extension is .tex, the pointset is drawn as a tikz figure in a .tex file. This file can be compiled using any latex compiler you want to generate a .pdf image.","title":"Description"},{"location":"io_tikz/#examples","text":"Input pointset Output .tex file Image sobol_128.edat sobol_128.tex stratified_25.dat stratified_25.tex toric_bnot_50.dat toric_bnot_50.tex","title":"Examples"},{"location":"license/","text":"/* * Coded by H\u00e9l\u00e8ne Perrier helene.perrier@liris.cnrs.fr * and David Coeurjolly David.coeurjolly@liris.cnrs.fr * * Copyright (c) 2018 CNRS Universit\u00e9 de Lyon * All rights reserved. *\u0013 * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are met: * * 1. Redistributions of source code must retain the above copyright notice, this * list of conditions and the following disclaimer. * 2. Redistributions in binary form must reproduce the above copyright notice, * this list of conditions and the following disclaimer in the documentation * and/or other materials provided with the distribution. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. * * The views and conclusions contained in the software and documentation are those * of the authors and should not be interpreted as representing official policies, * either expressed or implied, of the UTK project. */","title":"License"},{"location":"rendering_zoneplate/","text":"Zoneplate Test Files src/render/Zoneplate2D.hpp src/render/zoneplate_fromfile_2dd.cpp Description This test uses the point set given as input to reconstruct the followinf function sin(x^2+y^2) sin(x^2+y^2) . The number of samples per pixel can be given as parameter, and the resolution of the image to reconstruct is determined accordingly. A zoom factor can also be set to increase/decrease the range of frequencies. License BSD, see Zoneplate2D.hpp Execution Parameters: [HELP] -i [string] The input pointset -o [string] The output zoneplate -h Displays this help message -z [double] Zoom factor -p [uint=4] Nb samples per pixel To generate a zoneplate image from a given point set, one can use the following command line: ./src/render/zoneplate_fromfile_2dd -i wnois262k.dat -o zoneplate.png Or one can use the following C++ code: uint nbspp = 4 ; double zoom = 1.0 ; uint res = 512 ; utk :: Pointset < 2 , double , utk :: Point < 2 , double > > pts ; utk :: PointsetReader < 2 , double , utk :: Point < 2 , double > > pts_reader ; pts_reader . open ( \"wnois262k.dat\" ); pts_reader . readPointset ( pts ); pts_reader . close (); double scale = sqrt ( pts . size ()) / nbspp ; for ( uint i = 0 ; i < pts . size (); i ++ ) pts [ i ]. pos () *= scale ; Zoneplate zp ( res , 1 / zoom , nbspp ); zp . make ( pts ); zp . writePng ( \"zoneplate.png\" ); Results ./src/render/zoneplate_fromfile_2dd -i wnois262k.dat -o zoneplate.png File wnois262k.dat Pointset Zoneplate ./src/render/zoneplate_fromfile_2dd -i wnois262k.dat -o zoneplate_z15.png -z 1.5 File wnois262k.dat Pointset Zoneplate ./src/render/zoneplate_fromfile_2dd -i sobol262k.dat -o zoneplate_p4.png -p 4 File sobol262k.dat Pointset Zoneplate ./src/render/zoneplate_fromfile_2dd -i sobol262k.dat -o zoneplate_p1.png -p 1 -z 2 File sobol262k.dat Pointset Zoneplate","title":"Zoneplace Test"},{"location":"rendering_zoneplate/#zoneplate-test","text":"","title":"Zoneplate Test"},{"location":"rendering_zoneplate/#files","text":"src/render/Zoneplate2D.hpp src/render/zoneplate_fromfile_2dd.cpp","title":"Files"},{"location":"rendering_zoneplate/#description","text":"This test uses the point set given as input to reconstruct the followinf function sin(x^2+y^2) sin(x^2+y^2) . The number of samples per pixel can be given as parameter, and the resolution of the image to reconstruct is determined accordingly. A zoom factor can also be set to increase/decrease the range of frequencies.","title":"Description"},{"location":"rendering_zoneplate/#license","text":"BSD, see Zoneplate2D.hpp","title":"License"},{"location":"rendering_zoneplate/#execution","text":"Parameters: [HELP] -i [string] The input pointset -o [string] The output zoneplate -h Displays this help message -z [double] Zoom factor -p [uint=4] Nb samples per pixel To generate a zoneplate image from a given point set, one can use the following command line: ./src/render/zoneplate_fromfile_2dd -i wnois262k.dat -o zoneplate.png Or one can use the following C++ code: uint nbspp = 4 ; double zoom = 1.0 ; uint res = 512 ; utk :: Pointset < 2 , double , utk :: Point < 2 , double > > pts ; utk :: PointsetReader < 2 , double , utk :: Point < 2 , double > > pts_reader ; pts_reader . open ( \"wnois262k.dat\" ); pts_reader . readPointset ( pts ); pts_reader . close (); double scale = sqrt ( pts . size ()) / nbspp ; for ( uint i = 0 ; i < pts . size (); i ++ ) pts [ i ]. pos () *= scale ; Zoneplate zp ( res , 1 / zoom , nbspp ); zp . make ( pts ); zp . writePng ( \"zoneplate.png\" );","title":"Execution"},{"location":"rendering_zoneplate/#results","text":"./src/render/zoneplate_fromfile_2dd -i wnois262k.dat -o zoneplate.png File wnois262k.dat Pointset Zoneplate ./src/render/zoneplate_fromfile_2dd -i wnois262k.dat -o zoneplate_z15.png -z 1.5 File wnois262k.dat Pointset Zoneplate ./src/render/zoneplate_fromfile_2dd -i sobol262k.dat -o zoneplate_p4.png -p 4 File sobol262k.dat Pointset Zoneplate ./src/render/zoneplate_fromfile_2dd -i sobol262k.dat -o zoneplate_p1.png -p 1 -z 2 File sobol262k.dat Pointset Zoneplate","title":"Results"},{"location":"sampler_BNLDS/","text":"Sampler BNLDS Files src/samplers/SamplerBNLDS.hpp src/samplers/BNLDS_2dd.cpp Description Implementation of H\u00e9l\u00e8ne Perrier, David Coeurjolly, Feng Xie, Matt Pharr, Pat Hanrahan, Victor Ostromoukhov. Sequences with Low-Discrepancy Blue-Noise 2-D Projections. Computer Graphics Forum (Proceedings of Eurographics), 37(2):339\u2013353, 2018. See also https://perso.liris.cnrs.fr/david.coeurjolly/publications/perrier18eg.html . For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html . License BSD, see SamplerBNLDS.hpp . Execution Parameters: [HELP] -o [string=output_pts.dat] Output file -m [int=1] Number of poinset realisations -n [ullint=1024] Number of samples to generate --silent Silent mode -h Displays this help message --lut-in [string] the file containing the lookuptable --sobolD0 [uint=1] the sobol indices for dimension 0 --sobolD1 [uint=2] the sobol indices for dimension 1 -K [uint=4] the subdivision factor K --level [uint=-1] the level of subdivision (overrides the -n parameter) To generate a 2D point set of 1024 samples with a BNLDS distribution, we can use the following client line command: ./src/samplers/BNLDS_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter < 2 , double , Point < 2 , double > > writer ; writer . open ( \"toto.dat\" ); Pointset < 2 , double , Point < 2 , double > > pts ; . / src / samplers / SamplerBNLDS . hpp s ; unsigned int param_nbsamples = 1024 ; s . generateSamples < 2 , double , Point < 2 , double > > ( pts , param_nbsamples ); writer . writePointset ( pts ); writer . close (); Results Note that only the point sets containing K^{2n} samples are Blue Noise and Low Discrepancy, for K=4, 1024 is not a multiple of 4^{2n}, whereas 4096=4^6 (n=3). ./src/samplers/BNLDS_2dd -o BNLDS_1024.edat -n 1024 File BNLDS_1024.edat Pointset Fourier ./src/samplers/BNLDS_2dd -o BNLDS_4096.edat -n 4096 File BNLDS_4096.edat Pointset Fourier Changing the initial Sobol sequence ./src/samplers/BNLDS_2dd --sobolD0 3 --sobolD1 7 --lut-in ../data/BNLDS/factorK_4/Sobol_37/allPermutsCache_Sobol+OptPerms_3_7_00000.dat -o BNLDS_2_4096.edat -n 4096 File BNLDS_2_4096.edat Pointset Fourier Changing the K factor ./src/samplers/BNLDS_2dd -K 8 --sobolD0 1 --sobolD1 2 --lut-in ../data/BNLDS/factorK_8/fastoptim_lut_sobol1_2_k8_lvlmax3_sampler_BNLDS_optimizer_PCF_RandomOpti_2dd.dat -o BNLDS_3_4096.edat -n 4096 File BNLDS_3_4096.edat Pointset Fourier","title":"BNLD Sequences"},{"location":"sampler_BNLDS/#sampler-bnlds","text":"","title":"Sampler BNLDS"},{"location":"sampler_BNLDS/#files","text":"src/samplers/SamplerBNLDS.hpp src/samplers/BNLDS_2dd.cpp","title":"Files"},{"location":"sampler_BNLDS/#description","text":"Implementation of H\u00e9l\u00e8ne Perrier, David Coeurjolly, Feng Xie, Matt Pharr, Pat Hanrahan, Victor Ostromoukhov. Sequences with Low-Discrepancy Blue-Noise 2-D Projections. Computer Graphics Forum (Proceedings of Eurographics), 37(2):339\u2013353, 2018. See also https://perso.liris.cnrs.fr/david.coeurjolly/publications/perrier18eg.html . For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html .","title":"Description"},{"location":"sampler_BNLDS/#license","text":"BSD, see SamplerBNLDS.hpp .","title":"License"},{"location":"sampler_BNLDS/#execution","text":"Parameters: [HELP] -o [string=output_pts.dat] Output file -m [int=1] Number of poinset realisations -n [ullint=1024] Number of samples to generate --silent Silent mode -h Displays this help message --lut-in [string] the file containing the lookuptable --sobolD0 [uint=1] the sobol indices for dimension 0 --sobolD1 [uint=2] the sobol indices for dimension 1 -K [uint=4] the subdivision factor K --level [uint=-1] the level of subdivision (overrides the -n parameter) To generate a 2D point set of 1024 samples with a BNLDS distribution, we can use the following client line command: ./src/samplers/BNLDS_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter < 2 , double , Point < 2 , double > > writer ; writer . open ( \"toto.dat\" ); Pointset < 2 , double , Point < 2 , double > > pts ; . / src / samplers / SamplerBNLDS . hpp s ; unsigned int param_nbsamples = 1024 ; s . generateSamples < 2 , double , Point < 2 , double > > ( pts , param_nbsamples ); writer . writePointset ( pts ); writer . close ();","title":"Execution"},{"location":"sampler_BNLDS/#results","text":"Note that only the point sets containing K^{2n} samples are Blue Noise and Low Discrepancy, for K=4, 1024 is not a multiple of 4^{2n}, whereas 4096=4^6 (n=3). ./src/samplers/BNLDS_2dd -o BNLDS_1024.edat -n 1024 File BNLDS_1024.edat Pointset Fourier ./src/samplers/BNLDS_2dd -o BNLDS_4096.edat -n 4096 File BNLDS_4096.edat Pointset Fourier Changing the initial Sobol sequence ./src/samplers/BNLDS_2dd --sobolD0 3 --sobolD1 7 --lut-in ../data/BNLDS/factorK_4/Sobol_37/allPermutsCache_Sobol+OptPerms_3_7_00000.dat -o BNLDS_2_4096.edat -n 4096 File BNLDS_2_4096.edat Pointset Fourier Changing the K factor ./src/samplers/BNLDS_2dd -K 8 --sobolD0 1 --sobolD1 2 --lut-in ../data/BNLDS/factorK_8/fastoptim_lut_sobol1_2_k8_lvlmax3_sampler_BNLDS_optimizer_PCF_RandomOpti_2dd.dat -o BNLDS_3_4096.edat -n 4096 File BNLDS_3_4096.edat Pointset Fourier","title":"Results"},{"location":"sampler_BNOT/","text":"Sampler BNOT Files externals/bnot/* Description This sampler is a wrapper around the BNOT sampler from [de Goes et al 2012]. Due to its code complexity, this sampler was not ported within the UTK framework. It is therefore provided as an external party (in the externals folder). It was however slightly modified to allow using this sampler with similar parameters as other samples from UTK (very useful for scripting purposes). To compile this sampler, please do the following: cd externals/bnot mkdir build cd build cmake .. make Note that building bnot requires to have CGAL installed (version 4.9). For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html . License BSD for the UTK wrapper, GPL for bnot (see http://www.geometry.caltech.edu/BlueNoise/ ). Execution Parameters: [HELP] -o [string] Output file -m [int = 1] Number of poinset realisations -n [int = 1024] Number of samples to generate -h Displays this help message To generate a 2D point set of 1024 samples using BNOT, we can use the following client line command (from the buold folder): ../externals/bnot/build/pbnot -n 1024 -o toto.dat Results ../externals/bnot/build/pbnot -o BNOT_1024.edat -n 1024 File BNOT_1024.edat Pointset Fourier ../externals/bnot/build/pbnot -o BNOT_4096.edat -n 4096 File BNOT_4096.edat Pointset Fourier","title":"BNOT"},{"location":"sampler_BNOT/#sampler-bnot","text":"","title":"Sampler BNOT"},{"location":"sampler_BNOT/#files","text":"externals/bnot/*","title":"Files"},{"location":"sampler_BNOT/#description","text":"This sampler is a wrapper around the BNOT sampler from [de Goes et al 2012]. Due to its code complexity, this sampler was not ported within the UTK framework. It is therefore provided as an external party (in the externals folder). It was however slightly modified to allow using this sampler with similar parameters as other samples from UTK (very useful for scripting purposes). To compile this sampler, please do the following: cd externals/bnot mkdir build cd build cmake .. make Note that building bnot requires to have CGAL installed (version 4.9). For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html .","title":"Description"},{"location":"sampler_BNOT/#license","text":"BSD for the UTK wrapper, GPL for bnot (see http://www.geometry.caltech.edu/BlueNoise/ ).","title":"License"},{"location":"sampler_BNOT/#execution","text":"Parameters: [HELP] -o [string] Output file -m [int = 1] Number of poinset realisations -n [int = 1024] Number of samples to generate -h Displays this help message To generate a 2D point set of 1024 samples using BNOT, we can use the following client line command (from the buold folder): ../externals/bnot/build/pbnot -n 1024 -o toto.dat","title":"Execution"},{"location":"sampler_BNOT/#results","text":"../externals/bnot/build/pbnot -o BNOT_1024.edat -n 1024 File BNOT_1024.edat Pointset Fourier ../externals/bnot/build/pbnot -o BNOT_4096.edat -n 4096 File BNOT_4096.edat Pointset Fourier","title":"Results"},{"location":"sampler_CVT/","text":"Sampler CVT [BSD09] Files src/samplers/SamplerCapCVT.hpp src/samplers/CVT_2dd.cpp src/samplers/SamplerCapCVT/* Description Implementation of the CVT sampler from [BSD09] . For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html . Note This sampler requires an old version of the CGAL (v2) library. and set cmake .. -DUSE_CGALv2=true when generating the project. Requires CGAL v2 Execution Parameters: [HELP] --boundary [string] The file with the boundary of the domain --iter [int] The number of iterations -o [string=output_pts.dat] Output file -m [int=1] Number of poinset realisations -n [ullint=1024] Number of samples to generate --silent Silent mode -h Displays this help message To generate a 2D point set of 1024 samples with a CCVT distribution, we can use the following client line command: ./src/samplers/CVT_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter< 2, double, Point<2, double> > writer; writer.open(\"toto.dat\"); Pointset< 2, double, Point<2, double> > pts; SamplerCapCVT. s; uint nbIter=100; s.setIterations(nbIter); unsigned int param_nbsamples = 1024; s.generateSamples< 2, double, Point<2, double> >(pts, param_nbsamples); writer.writePointset(pts); writer.close(); Results ./src/samplers/CCVT_2dd -o CVT_1024.edat -n 1024 File CCVT_1024.edat Pointset Fourier ./src/samplers/CCVT_2dd -o CVT_4096.edat -n 4096 File CCVT_4096.edat Pointset Fourier ./src/samplers/CVT_2dd -o CVT_2_4096.edat -n 4096 --iter 10 File CVT_2_4096.edat Pointset Fourier","title":"CVT"},{"location":"sampler_CVT/#sampler-cvt-bsd09","text":"","title":"Sampler CVT [BSD09]"},{"location":"sampler_CVT/#files","text":"src/samplers/SamplerCapCVT.hpp src/samplers/CVT_2dd.cpp src/samplers/SamplerCapCVT/*","title":"Files"},{"location":"sampler_CVT/#description","text":"Implementation of the CVT sampler from [BSD09] . For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html . Note This sampler requires an old version of the CGAL (v2) library. and set cmake .. -DUSE_CGALv2=true when generating the project. Requires CGAL v2","title":"Description"},{"location":"sampler_CVT/#execution","text":"Parameters: [HELP] --boundary [string] The file with the boundary of the domain --iter [int] The number of iterations -o [string=output_pts.dat] Output file -m [int=1] Number of poinset realisations -n [ullint=1024] Number of samples to generate --silent Silent mode -h Displays this help message To generate a 2D point set of 1024 samples with a CCVT distribution, we can use the following client line command: ./src/samplers/CVT_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter< 2, double, Point<2, double> > writer; writer.open(\"toto.dat\"); Pointset< 2, double, Point<2, double> > pts; SamplerCapCVT. s; uint nbIter=100; s.setIterations(nbIter); unsigned int param_nbsamples = 1024; s.generateSamples< 2, double, Point<2, double> >(pts, param_nbsamples); writer.writePointset(pts); writer.close();","title":"Execution"},{"location":"sampler_CVT/#results","text":"./src/samplers/CCVT_2dd -o CVT_1024.edat -n 1024 File CCVT_1024.edat Pointset Fourier ./src/samplers/CCVT_2dd -o CVT_4096.edat -n 4096 File CCVT_4096.edat Pointset Fourier ./src/samplers/CVT_2dd -o CVT_2_4096.edat -n 4096 --iter 10 File CVT_2_4096.edat Pointset Fourier","title":"Results"},{"location":"sampler_CapCVT/","text":"Sampler CapCVT [CYC12] Files src/samplers/SamplerCapCVT.hpp src/samplers/CapCVT_2dd.cpp src/samplers/SamplerCapCVT/ Description Implementation of the CapCVT sampler from [CYC12] . For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html . Note This sampler requires an old version of the CGAL (v2) library. and set cmake .. -DUSE_CGALv2=true when generating the project. Execution Parameters: [HELP] --boundary [string] The file with the boundary of the domain --iter [int] The number of iterations --lambda [float] The lambda value -o [string=output_pts.dat] Output file -m [int=1] Number of poinset realisations -n [ullint=1024] Number of samples to generate --silent Silent mode -h Displays this help message To generate a 2D point set of 1024 samples with a CapCVT distribution, we can use the following client line command: ./src/samplers/CapCVT_2dd -n 1024 -o toto.dat Or one can use the following C++ code: cpp PointsetWriter< 2, double, Point<2, double> > writer; writer.open(\"toto.dat\"); Pointset< 2, double, Point<2, double> > pts; SamplerCapCVT s; double lambda=30.0; s.setLambda(lambda); uint nbIter=100; s.setIterations(nbIter); unsigned int param_nbsamples = 1024; s.generateSamples< 2, double, Point<2, double> >(pts, param_nbsamples); writer.writePointset(pts); writer.close(); Results ./src/samplers/CapCVT_2dd -o CapCVT_1024.edat -n 1024 File CapCVT_1024.edat Pointset Fourier ./src/samplers/CapCVT_2dd -o CapCVT_4096.edat -n 4096 File CapCVT_4096.edat Pointset Fourier ./src/samplers/CapCVT_2dd -o CapCVT_2_1024.edat -n 1024 --lambda 10 File CapCVT_2_1024.edat Pointset Fourier ./src/samplers/CapCVT_2dd -o CapCVT_2_1024.edat -n 1024 --iter 10 File CapCVT_3_1024.edat Pointset Fourier","title":"CapCVT"},{"location":"sampler_CapCVT/#sampler-capcvt-cyc12","text":"","title":"Sampler CapCVT [CYC12]"},{"location":"sampler_CapCVT/#files","text":"src/samplers/SamplerCapCVT.hpp src/samplers/CapCVT_2dd.cpp src/samplers/SamplerCapCVT/","title":"Files"},{"location":"sampler_CapCVT/#description","text":"Implementation of the CapCVT sampler from [CYC12] . For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html . Note This sampler requires an old version of the CGAL (v2) library. and set cmake .. -DUSE_CGALv2=true when generating the project.","title":"Description"},{"location":"sampler_CapCVT/#execution","text":"Parameters: [HELP] --boundary [string] The file with the boundary of the domain --iter [int] The number of iterations --lambda [float] The lambda value -o [string=output_pts.dat] Output file -m [int=1] Number of poinset realisations -n [ullint=1024] Number of samples to generate --silent Silent mode -h Displays this help message To generate a 2D point set of 1024 samples with a CapCVT distribution, we can use the following client line command: ./src/samplers/CapCVT_2dd -n 1024 -o toto.dat Or one can use the following C++ code: cpp PointsetWriter< 2, double, Point<2, double> > writer; writer.open(\"toto.dat\"); Pointset< 2, double, Point<2, double> > pts; SamplerCapCVT s; double lambda=30.0; s.setLambda(lambda); uint nbIter=100; s.setIterations(nbIter); unsigned int param_nbsamples = 1024; s.generateSamples< 2, double, Point<2, double> >(pts, param_nbsamples); writer.writePointset(pts); writer.close();","title":"Execution"},{"location":"sampler_CapCVT/#results","text":"./src/samplers/CapCVT_2dd -o CapCVT_1024.edat -n 1024 File CapCVT_1024.edat Pointset Fourier ./src/samplers/CapCVT_2dd -o CapCVT_4096.edat -n 4096 File CapCVT_4096.edat Pointset Fourier ./src/samplers/CapCVT_2dd -o CapCVT_2_1024.edat -n 1024 --lambda 10 File CapCVT_2_1024.edat Pointset Fourier ./src/samplers/CapCVT_2dd -o CapCVT_2_1024.edat -n 1024 --iter 10 File CapCVT_3_1024.edat Pointset Fourier","title":"Results"},{"location":"sampler_FPO/","text":"Sampler FPO [SHD11] Files src/samplers/SamplerFPO.hpp src/samplers/SamplerFPO/* src/bin/samplers/FPO_2dd.cpp Description Implementation from the stk library of the sampler from [SHD11] . For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html . Note This sampler requires an old version of the CGAL (v2) library. and set cmake .. -DUSE_CGALv2=true when generating the project. Execution Parameters: [HELP] -o [string = output_pts.dat] Output file -m [int = 1] Number of poinset realisations -n [ullint = 1024] Number of samples to generate --silent Silent mode -h Displays this help message To generate a 2D point set of 1024 samples with a FPO distribution, we can use the following client line command: ./src/samplers/FPO_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter< 2, double, Point<2, double> > writer; writer.open(\"toto.dat\"); Pointset< 2, double, Point<2, double> > pts; SamplerFPO s; unsigned int param_nbsamples = 1024; s.generateSamples< 2, double, Point<2, double> >(pts, param_nbsamples); writer.writePointset(pts); writer.close(); Results ./src/samplers/FPO_2dd -o FPO_1024.edat -n 1024 File FPO_1024.edat Pointset Fourier ./src/samplers/FPO_2dd -o FPO_4096.edat -n 4096 File FPO_4096.edat Pointset Fourier","title":"FPO"},{"location":"sampler_FPO/#sampler-fpo-shd11","text":"","title":"Sampler FPO [SHD11]"},{"location":"sampler_FPO/#files","text":"src/samplers/SamplerFPO.hpp src/samplers/SamplerFPO/* src/bin/samplers/FPO_2dd.cpp","title":"Files"},{"location":"sampler_FPO/#description","text":"Implementation from the stk library of the sampler from [SHD11] . For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html . Note This sampler requires an old version of the CGAL (v2) library. and set cmake .. -DUSE_CGALv2=true when generating the project.","title":"Description"},{"location":"sampler_FPO/#execution","text":"Parameters: [HELP] -o [string = output_pts.dat] Output file -m [int = 1] Number of poinset realisations -n [ullint = 1024] Number of samples to generate --silent Silent mode -h Displays this help message To generate a 2D point set of 1024 samples with a FPO distribution, we can use the following client line command: ./src/samplers/FPO_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter< 2, double, Point<2, double> > writer; writer.open(\"toto.dat\"); Pointset< 2, double, Point<2, double> > pts; SamplerFPO s; unsigned int param_nbsamples = 1024; s.generateSamples< 2, double, Point<2, double> >(pts, param_nbsamples); writer.writePointset(pts); writer.close();","title":"Execution"},{"location":"sampler_FPO/#results","text":"./src/samplers/FPO_2dd -o FPO_1024.edat -n 1024 File FPO_1024.edat Pointset Fourier ./src/samplers/FPO_2dd -o FPO_4096.edat -n 4096 File FPO_4096.edat Pointset Fourier","title":"Results"},{"location":"sampler_Lloyd/","text":"Sampler Lloyd 3D Files src/samplers/SamplerLloyd.hpp src/samplers/SamplerLloyd/ src/samplers/Lloyd_3dd.cpp Description This sampler is a wrapper around the geogram library for an efficient implementation of periodic and non-periodic Delaunay triangulation in 3D. The Lloyd_3dd sampler is a standard implementation of Lloyd\u2019s relaxation algorithm. License BSD for the UTK wrapper. Geogram is licensed under the 3-clauses BSD License (also called \u201cRevised BSD License\u201d, \u201cNew BSD License\u201d, or \u201cModified BSD License\u201d). Execution Parameters: [HELP] -o [string=output_pts.dat] Output file -m [int=1] Number of poinset realisations -n [ullint=1024] Number of samples to generate --silent Silent mode -h Displays this help message -s [int=100] Number of Lloyd's steps -t [bool=false] Activate Toroidal domain To generate 4 realizations of a 3D toroidal point set of 1024 samples with 500 Lloyd\u2019s steps, we can use the following client line command (from the buold folder): ./bin/Lloyd_3dd -n 1024 -o toto.dat -t -m 4 -s 500 Results","title":"Lloyd3D"},{"location":"sampler_Lloyd/#sampler-lloyd-3d","text":"","title":"Sampler Lloyd 3D"},{"location":"sampler_Lloyd/#files","text":"src/samplers/SamplerLloyd.hpp src/samplers/SamplerLloyd/ src/samplers/Lloyd_3dd.cpp","title":"Files"},{"location":"sampler_Lloyd/#description","text":"This sampler is a wrapper around the geogram library for an efficient implementation of periodic and non-periodic Delaunay triangulation in 3D. The Lloyd_3dd sampler is a standard implementation of Lloyd\u2019s relaxation algorithm.","title":"Description"},{"location":"sampler_Lloyd/#license","text":"BSD for the UTK wrapper. Geogram is licensed under the 3-clauses BSD License (also called \u201cRevised BSD License\u201d, \u201cNew BSD License\u201d, or \u201cModified BSD License\u201d).","title":"License"},{"location":"sampler_Lloyd/#execution","text":"Parameters: [HELP] -o [string=output_pts.dat] Output file -m [int=1] Number of poinset realisations -n [ullint=1024] Number of samples to generate --silent Silent mode -h Displays this help message -s [int=100] Number of Lloyd's steps -t [bool=false] Activate Toroidal domain To generate 4 realizations of a 3D toroidal point set of 1024 samples with 500 Lloyd\u2019s steps, we can use the following client line command (from the buold folder): ./bin/Lloyd_3dd -n 1024 -o toto.dat -t -m 4 -s 500","title":"Execution"},{"location":"sampler_Lloyd/#results","text":"","title":"Results"},{"location":"sampler_PMJ/","text":"Sampler PMJ [PMJ] Files src/samplers/SamplerPMJ/ src/samplers/ProgressiveJittered_2dd.cpp src/samplers/ProgressiveMultiJittered_2dd.cpp src/samplers/ProgressiveMultiJittered02_2dd.cpp src/samplers/ProgressiveMultiJittered02_Pharr_2dd.cpp Description The Progressive Multi-Jittered sampler. This sampler is divided in 3 techniques, each giving better results than the previous one: Progressive Jittered (PJ): Divides the unit square into 4 equal squares. Randomly throws a point into each subsquare. Then divide those subsquares into subsubsquares. Randomly throws points in them, and so on. Progressive Multi-Jittered (PMJ): Adds to PJ one property: Using PJ, each sample falls into its own square subdivision. With PMJ, each sample falls into its own square subdivision AND its own strata. When throwing points, uses a best candidate algorithm. Progressive Multi-Jittered(0,2) (PMJ02): Generalizes the previous techniques. If we subdivide the unit square into equal rectangles, each sample falls into its own rectangle. C++ Implementation of [PMJ] ProgressiveMultiJittered02_Pharr_2dd implements Matt Pharr\u2019s variant from the JCGT article \u201cEfficient Generation of Points that Satisfy Two-Dimensional Elementary Intervals\u201d focusing on fast PMJ02 sampling. License BSD, see source codes Execution Parameters: [HELP] -o [string=output_pts.dat] Output file -n [ullint=1024] Number of samples to generate -s [int=0] Seed -c [int=10] For PMJ Sampler, number of candidates for best candidates selection. To generate a 2D point set of 1024 samples with a PMJ distribution using 20 candidates, we can use the following client line command: ./bin/samplers/ProgressiveMultiJittered_2dd -n 1024 -o toto.dat -s 0 -c 20 Results File PJ____ 1024.dat Pointset Fourier File PMJ___1024.dat Pointset Fourier File PMJ02_1024.dat Pointset Fourier File PMJ02_4096.dat Pointset Fourier","title":"Progressive MultiJittered Sampling"},{"location":"sampler_PMJ/#sampler-pmj-pmj","text":"","title":"Sampler PMJ [PMJ]"},{"location":"sampler_PMJ/#files","text":"src/samplers/SamplerPMJ/ src/samplers/ProgressiveJittered_2dd.cpp src/samplers/ProgressiveMultiJittered_2dd.cpp src/samplers/ProgressiveMultiJittered02_2dd.cpp src/samplers/ProgressiveMultiJittered02_Pharr_2dd.cpp","title":"Files"},{"location":"sampler_PMJ/#description","text":"The Progressive Multi-Jittered sampler. This sampler is divided in 3 techniques, each giving better results than the previous one: Progressive Jittered (PJ): Divides the unit square into 4 equal squares. Randomly throws a point into each subsquare. Then divide those subsquares into subsubsquares. Randomly throws points in them, and so on. Progressive Multi-Jittered (PMJ): Adds to PJ one property: Using PJ, each sample falls into its own square subdivision. With PMJ, each sample falls into its own square subdivision AND its own strata. When throwing points, uses a best candidate algorithm. Progressive Multi-Jittered(0,2) (PMJ02): Generalizes the previous techniques. If we subdivide the unit square into equal rectangles, each sample falls into its own rectangle. C++ Implementation of [PMJ] ProgressiveMultiJittered02_Pharr_2dd implements Matt Pharr\u2019s variant from the JCGT article \u201cEfficient Generation of Points that Satisfy Two-Dimensional Elementary Intervals\u201d focusing on fast PMJ02 sampling.","title":"Description"},{"location":"sampler_PMJ/#license","text":"BSD, see source codes","title":"License"},{"location":"sampler_PMJ/#execution","text":"Parameters: [HELP] -o [string=output_pts.dat] Output file -n [ullint=1024] Number of samples to generate -s [int=0] Seed -c [int=10] For PMJ Sampler, number of candidates for best candidates selection. To generate a 2D point set of 1024 samples with a PMJ distribution using 20 candidates, we can use the following client line command: ./bin/samplers/ProgressiveMultiJittered_2dd -n 1024 -o toto.dat -s 0 -c 20","title":"Execution"},{"location":"sampler_PMJ/#results","text":"File PJ____ 1024.dat Pointset Fourier File PMJ___1024.dat Pointset Fourier File PMJ02_1024.dat Pointset Fourier File PMJ02_4096.dat Pointset Fourier","title":"Results"},{"location":"sampler_aapatterns/","text":"Sampler AA Patterns [Ahm16] Files src/samplers/SamplerAAPattern.hpp src/bin/samplers/AAPatterns_2dd.cpp.cpp Description The AA Pattern sampler from [Ahm16] . For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html . License /* Generate a distribution based on an AA pattern and a loadable displacement map * Values which depend on pattern parameters are read from a header file so * that different parameters can be used with this code. * We could also load these dynamically, but hard-coding them gives substantial speedup * Created by Abdalla Ahmed * 2014-11-11 * Last revision 2015-09-10 */ Execution Parameters: [HELP] -o [string=output_pts.dat] Output file -m [int=1] Number of poinset realisations -n [ullint=1024] Number of samples to generate --silent Silent mode -h Displays this help message -d File containing the displacement vectors To generate a 2D point set of 1024 samples with a aapatterns distribution, we can use the following client line command: ./bin/samplers/AAPatterns_2dd -d ../../data/aapatterns/blue.dat -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter < 2 , double , Point < 2 , double > > writer ; writer . open ( \"toto.dat\" ); Pointset < 2 , double , Point < 2 , double > > pts ; SamplerAAPattern s ; unsigned int param_nbsamples = 1024 ; s . generateSamples < 2 , double , Point < 2 , double > > ( pts , param_nbsamples ); writer . writePointset ( pts ); writer . close (); Results ./bin/samplers/AAPatterns_2dd -d ../../data/aapatterns/blue.dat -o aapatterns_1024.edat -n 1024 File aapatterns_1024.edat Pointset Fourier ./bin/samplers/AAPatterns_2dd -d ../../data/aapatterns/blue.dat -o aapatterns_4096.edat -n 4096 File aapatterns_4096.edat Pointset Fourier This sampler can also match various distributions ./bin/samplers/AAPatterns_2dd -d ../../data/aapatterns/green.dat -o aapatterns_green_1024.edat -n 1024 File aapatterns_green_1024.edat Pointset Fourier ./bin/samplers/AAPatterns_2dd -d ../../data/aapatterns/pink.dat -o aapatterns_pink_1024.edat -n 1024 File aapatterns_pink_1024.edat Pointset Fourier ./bin/samplers/AAPatterns_2dd -d ../../data/aapatterns/step.dat -o aapatterns_step_1024.edat -n 1024 File aapatterns_step_1024.edat Pointset Fourier","title":"AA Patterns"},{"location":"sampler_aapatterns/#sampler-aa-patterns-ahm16","text":"","title":"Sampler AA Patterns [Ahm16]"},{"location":"sampler_aapatterns/#files","text":"src/samplers/SamplerAAPattern.hpp src/bin/samplers/AAPatterns_2dd.cpp.cpp","title":"Files"},{"location":"sampler_aapatterns/#description","text":"The AA Pattern sampler from [Ahm16] . For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html .","title":"Description"},{"location":"sampler_aapatterns/#license","text":"/* Generate a distribution based on an AA pattern and a loadable displacement map * Values which depend on pattern parameters are read from a header file so * that different parameters can be used with this code. * We could also load these dynamically, but hard-coding them gives substantial speedup * Created by Abdalla Ahmed * 2014-11-11 * Last revision 2015-09-10 */","title":"License"},{"location":"sampler_aapatterns/#execution","text":"Parameters: [HELP] -o [string=output_pts.dat] Output file -m [int=1] Number of poinset realisations -n [ullint=1024] Number of samples to generate --silent Silent mode -h Displays this help message -d File containing the displacement vectors To generate a 2D point set of 1024 samples with a aapatterns distribution, we can use the following client line command: ./bin/samplers/AAPatterns_2dd -d ../../data/aapatterns/blue.dat -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter < 2 , double , Point < 2 , double > > writer ; writer . open ( \"toto.dat\" ); Pointset < 2 , double , Point < 2 , double > > pts ; SamplerAAPattern s ; unsigned int param_nbsamples = 1024 ; s . generateSamples < 2 , double , Point < 2 , double > > ( pts , param_nbsamples ); writer . writePointset ( pts ); writer . close ();","title":"Execution"},{"location":"sampler_aapatterns/#results","text":"./bin/samplers/AAPatterns_2dd -d ../../data/aapatterns/blue.dat -o aapatterns_1024.edat -n 1024 File aapatterns_1024.edat Pointset Fourier ./bin/samplers/AAPatterns_2dd -d ../../data/aapatterns/blue.dat -o aapatterns_4096.edat -n 4096 File aapatterns_4096.edat Pointset Fourier This sampler can also match various distributions ./bin/samplers/AAPatterns_2dd -d ../../data/aapatterns/green.dat -o aapatterns_green_1024.edat -n 1024 File aapatterns_green_1024.edat Pointset Fourier ./bin/samplers/AAPatterns_2dd -d ../../data/aapatterns/pink.dat -o aapatterns_pink_1024.edat -n 1024 File aapatterns_pink_1024.edat Pointset Fourier ./bin/samplers/AAPatterns_2dd -d ../../data/aapatterns/step.dat -o aapatterns_step_1024.edat -n 1024 File aapatterns_step_1024.edat Pointset Fourier","title":"Results"},{"location":"sampler_art/","text":"Sampler ART [ANH*17] Files src/samplers/SamplerART.hpp src/bin/samplers/ART_2dd.cpp.cpp Description The sampler from [ANH*17] For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html . License See author\u2019s page. Execution Parameters: [HELP] -o [string = output_pts.dat] Output file -m [int = 1] Number of poinset realisations -n [ullint = 1024] Number of samples to generate --silent Silent mode -h Displays this help message -d File containing the tiles offsets To generate a 2D point set of 1024 samples with a art distribution, we can use the following client line command: ./bin/samplers/ART_2dd -d ../../data/ART/table.dat -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter< 2, double, Point<2, double> > writer; writer.open(\"toto.dat\"); Pointset< 2, double, Point<2, double> > pts; SamplerART s; unsigned int param_nbsamples = 1024; s.generateSamples< 2, double, Point<2, double> >(pts, param_nbsamples); writer.writePointset(pts); writer.close(); Results ./bin/samplers/ART_2dd -d ../../data/ART/table.dat -o art_1024.edat -n 1024 File art_1024.edat Pointset Fourier ./bin/samplers/ART_2dd -d ../../data/ART/table.dat -o art_4096.edat -n 4096 File art_4096.edat Pointset Fourier","title":"ART"},{"location":"sampler_art/#sampler-art-anh17","text":"","title":"Sampler ART [ANH*17]"},{"location":"sampler_art/#files","text":"src/samplers/SamplerART.hpp src/bin/samplers/ART_2dd.cpp.cpp","title":"Files"},{"location":"sampler_art/#description","text":"The sampler from [ANH*17] For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html .","title":"Description"},{"location":"sampler_art/#license","text":"See author\u2019s page.","title":"License"},{"location":"sampler_art/#execution","text":"Parameters: [HELP] -o [string = output_pts.dat] Output file -m [int = 1] Number of poinset realisations -n [ullint = 1024] Number of samples to generate --silent Silent mode -h Displays this help message -d File containing the tiles offsets To generate a 2D point set of 1024 samples with a art distribution, we can use the following client line command: ./bin/samplers/ART_2dd -d ../../data/ART/table.dat -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter< 2, double, Point<2, double> > writer; writer.open(\"toto.dat\"); Pointset< 2, double, Point<2, double> > pts; SamplerART s; unsigned int param_nbsamples = 1024; s.generateSamples< 2, double, Point<2, double> >(pts, param_nbsamples); writer.writePointset(pts); writer.close();","title":"Execution"},{"location":"sampler_art/#results","text":"./bin/samplers/ART_2dd -d ../../data/ART/table.dat -o art_1024.edat -n 1024 File art_1024.edat Pointset Fourier ./bin/samplers/ART_2dd -d ../../data/ART/table.dat -o art_4096.edat -n 4096 File art_4096.edat Pointset Fourier","title":"Results"},{"location":"sampler_cmj/","text":"Sampler Correlated Multi Jittered [Ken03] Files src/samplers/SamplerCMJ.hpp src/bin/samplers/CMJ_2dd.cpp Description The Correlated Multi-Jitter sampler from [Kens03] . For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html . License BSD, see SamplerCMJ.hpp Execution Parameters: [HELP] -o [string = output_pts.dat] Output file -m [int = 1] Number of poinset realisations -n [ullint = 1024] Number of samples to generate --silent Silent mode -h Displays this help message To generate a 2D point set of 1024 samples with a cmj distribution, we can use the following client line command: ./bin/samplers/CMJ_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter< 2, double, Point<2, double> > writer; writer.open(\"toto.dat\"); Pointset< 2, double, Point<2, double> > pts; SamplerCMJ s; unsigned int param_nbsamples = 1024; s.generateSamples< 2, double, Point<2, double> >(pts, param_nbsamples); writer.writePointset(pts); writer.close(); Results ./bin/samplers/CMJ_2dd -o cmj_1024.edat -n 1024 File cmj_1024.edat Pointset Fourier ./bin/samplers/CMJ_2dd -o cmj_4096.edat -n 4096 File cmj_4096.edat Pointset Fourier","title":"CMJ"},{"location":"sampler_cmj/#sampler-correlated-multi-jittered-ken03","text":"","title":"Sampler Correlated Multi Jittered [Ken03]"},{"location":"sampler_cmj/#files","text":"src/samplers/SamplerCMJ.hpp src/bin/samplers/CMJ_2dd.cpp","title":"Files"},{"location":"sampler_cmj/#description","text":"The Correlated Multi-Jitter sampler from [Kens03] . For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html .","title":"Description"},{"location":"sampler_cmj/#license","text":"BSD, see SamplerCMJ.hpp","title":"License"},{"location":"sampler_cmj/#execution","text":"Parameters: [HELP] -o [string = output_pts.dat] Output file -m [int = 1] Number of poinset realisations -n [ullint = 1024] Number of samples to generate --silent Silent mode -h Displays this help message To generate a 2D point set of 1024 samples with a cmj distribution, we can use the following client line command: ./bin/samplers/CMJ_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter< 2, double, Point<2, double> > writer; writer.open(\"toto.dat\"); Pointset< 2, double, Point<2, double> > pts; SamplerCMJ s; unsigned int param_nbsamples = 1024; s.generateSamples< 2, double, Point<2, double> >(pts, param_nbsamples); writer.writePointset(pts); writer.close();","title":"Execution"},{"location":"sampler_cmj/#results","text":"./bin/samplers/CMJ_2dd -o cmj_1024.edat -n 1024 File cmj_1024.edat Pointset Fourier ./bin/samplers/CMJ_2dd -o cmj_4096.edat -n 4096 File cmj_4096.edat Pointset Fourier","title":"Results"},{"location":"sampler_dart_throwing/","text":"Sampler Dart Throwing [MF92] Files src/samplers/SamplerDartThrowing.hpp src/bin/samplers/DartThrowing_2dd.cpp Description A naive (relaxed) dart throwing algorithm. For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html . License BSD, see SamplerDartThrowing.hpp Execution Parameters: [HELP] -o [string = output_pts.dat] Output file -m [int = 1] Number of poinset realisations -n [ullint = 1024] Number of samples to generate --silent Silent mode -h Displays this help message --relaxed Use relaxed dart throwing To generate a 2D point set of 1024 samples with a dart_throwing distribution, we can use the following client line command: ./bin/samplers/DartThrowing_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter< 2, double, Point<2, double> > writer; writer.open(\"toto.dat\"); Pointset< 2, double, Point<2, double> > pts; SamplerDartThrowing s; unsigned int param_nbsamples = 1024; s.generateSamples< 2, double, Point<2, double> >(pts, param_nbsamples); writer.writePointset(pts); writer.close(); Results ./bin/samplers/DartThrowing_2dd -o dart_throwing_1024.edat -n 1024 File dart_throwing_1024.edat Pointset Fourier ./bin/samplers/DartThrowing_2dd -o dart_throwing_4096.edat -n 4096 File dart_throwing_4096.edat Pointset Fourier ./bin/samplers/DartThrowing_2dd --relaxed -o dart_throwing_relaxed_1024.edat -n 1024 File dart_throwing_relaxed_1024.edat Pointset Fourier ./bin/samplers/DartThrowing_2dd --relaxed -o dart_throwing_relaxed_4096.edat -n 4096 File dart_throwing_relaxed_4096.edat Pointset Fourier","title":"Dart Throwing"},{"location":"sampler_dart_throwing/#sampler-dart-throwing-mf92","text":"","title":"Sampler Dart Throwing [MF92]"},{"location":"sampler_dart_throwing/#files","text":"src/samplers/SamplerDartThrowing.hpp src/bin/samplers/DartThrowing_2dd.cpp","title":"Files"},{"location":"sampler_dart_throwing/#description","text":"A naive (relaxed) dart throwing algorithm. For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html .","title":"Description"},{"location":"sampler_dart_throwing/#license","text":"BSD, see SamplerDartThrowing.hpp","title":"License"},{"location":"sampler_dart_throwing/#execution","text":"Parameters: [HELP] -o [string = output_pts.dat] Output file -m [int = 1] Number of poinset realisations -n [ullint = 1024] Number of samples to generate --silent Silent mode -h Displays this help message --relaxed Use relaxed dart throwing To generate a 2D point set of 1024 samples with a dart_throwing distribution, we can use the following client line command: ./bin/samplers/DartThrowing_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter< 2, double, Point<2, double> > writer; writer.open(\"toto.dat\"); Pointset< 2, double, Point<2, double> > pts; SamplerDartThrowing s; unsigned int param_nbsamples = 1024; s.generateSamples< 2, double, Point<2, double> >(pts, param_nbsamples); writer.writePointset(pts); writer.close();","title":"Execution"},{"location":"sampler_dart_throwing/#results","text":"./bin/samplers/DartThrowing_2dd -o dart_throwing_1024.edat -n 1024 File dart_throwing_1024.edat Pointset Fourier ./bin/samplers/DartThrowing_2dd -o dart_throwing_4096.edat -n 4096 File dart_throwing_4096.edat Pointset Fourier ./bin/samplers/DartThrowing_2dd --relaxed -o dart_throwing_relaxed_1024.edat -n 1024 File dart_throwing_relaxed_1024.edat Pointset Fourier ./bin/samplers/DartThrowing_2dd --relaxed -o dart_throwing_relaxed_4096.edat -n 4096 File dart_throwing_relaxed_4096.edat Pointset Fourier","title":"Results"},{"location":"sampler_exhaustive_owen/","text":"Sampler Exhaustive Owen Files src/samplers/SamplerExhaustiveOwen.hpp src/bin/samplers/ExaustiveOwen_2dd.cpp.cpp Description Owen\u2019s scrambling uses a permutation tree in each dimension. This tree is usually randomly filled. For a set containing n samples, it contains N flags, with N=n-1. This sampler tests all 2^N possible trees (in each dimension) and returns the trees that generates the most Blue Noise like set. As this exhaustive search is very computationally expensive, this sampler can only generate point sets of size n lesser than 32. License BSD, see SamplerExhaustiveOwen.hpp Execution Parameters: [HELP] -o [string=output_pts.dat] Output file -m [int=1] Number of poinset realisations -n [ullint=1024] Number of samples to generate --silent Silent mode -h Displays this help message ``` To generate a 2D point set of 1024 samples with a exhaustive_owen distribution, we can use the following client line command: ./bin/samplers/ExhautiveOwen_2dd -n 1024 -o toto.dat Or one can use the following C++ code: ``` cpp PointsetWriter< 2, double, Point<2, double> > writer; writer.open(\"toto.dat\"); Pointset< 2, double, Point<2, double> > pts; SamplerExhaustiveOwen s; unsigned int param_nbsamples = 1024; s.generateSamples< 2, double, Point<2, double> >(pts, param_nbsamples); writer.writePointset(pts); writer.close(); Results ./bin/samplers/ExhautiveOwen_2dd -o exhaustive_owen_16.edat -n 16 File exhaustive_owen_16.edat Pointset Fourier","title":"Sampler Exhaustive Owen"},{"location":"sampler_exhaustive_owen/#sampler-exhaustive-owen","text":"","title":"Sampler Exhaustive Owen"},{"location":"sampler_exhaustive_owen/#files","text":"src/samplers/SamplerExhaustiveOwen.hpp src/bin/samplers/ExaustiveOwen_2dd.cpp.cpp","title":"Files"},{"location":"sampler_exhaustive_owen/#description","text":"Owen\u2019s scrambling uses a permutation tree in each dimension. This tree is usually randomly filled. For a set containing n samples, it contains N flags, with N=n-1. This sampler tests all 2^N possible trees (in each dimension) and returns the trees that generates the most Blue Noise like set. As this exhaustive search is very computationally expensive, this sampler can only generate point sets of size n lesser than 32.","title":"Description"},{"location":"sampler_exhaustive_owen/#license","text":"BSD, see SamplerExhaustiveOwen.hpp","title":"License"},{"location":"sampler_exhaustive_owen/#execution","text":"Parameters: [HELP] -o [string=output_pts.dat] Output file -m [int=1] Number of poinset realisations -n [ullint=1024] Number of samples to generate --silent Silent mode -h Displays this help message ``` To generate a 2D point set of 1024 samples with a exhaustive_owen distribution, we can use the following client line command: ./bin/samplers/ExhautiveOwen_2dd -n 1024 -o toto.dat Or one can use the following C++ code: ``` cpp PointsetWriter< 2, double, Point<2, double> > writer; writer.open(\"toto.dat\"); Pointset< 2, double, Point<2, double> > pts; SamplerExhaustiveOwen s; unsigned int param_nbsamples = 1024; s.generateSamples< 2, double, Point<2, double> >(pts, param_nbsamples); writer.writePointset(pts); writer.close();","title":"Execution"},{"location":"sampler_exhaustive_owen/#results","text":"./bin/samplers/ExhautiveOwen_2dd -o exhaustive_owen_16.edat -n 16 File exhaustive_owen_16.edat Pointset Fourier","title":"Results"},{"location":"sampler_experimental/","text":"Experimental Samplers Exhaustive Owen Genetic Owen Gradient descent","title":"Sampler experimental"},{"location":"sampler_fastpoisson/","text":"Sampler Fast Poisson [Bri07] Files src/samplers/SamplerFastPoisson.hpp src/bin/samplers/FastPoisson_2dd.cpp.cpp Description The Fast Poisson sampler from [DH06] . For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html . License Public Domain: This code is released into the public domain. You can do whatever you want with it. I do ask that you respect the authorship and credit myself (Daniel Dunbar) when referencing the code. Additionally, if you use the code in an interesting or integral manner I would like to hear about it. Execution Parameters: [HELP] -o [string = output_pts.dat] Output file -m [int = 1] Number of poinset realisations -n [ullint = 1024] Number of samples to generate --silent Silent mode -h Displays this help message --method [string = DartThrowing] The method to use to generate the samples (DartThrowing | Pure | LinearPure) --minmaxthrows [int = 100] set minimum number of maximum throws for DartThrowing sampler --mult [int = 1] set multiplier for DartThrowing sampler --tiled If set, use tiled domain To generate a 2D point set of 1024 samples with a fastpoisson distribution, we can use the following client line command: ./bin/samplers/FastPoisson_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter< 2, double, Point<2, double> > writer; writer.open(\"toto.dat\"); Pointset< 2, double, Point<2, double> > pts; SamplerFastPoisson s; unsigned int param_nbsamples = 1024; s.generateSamples< 2, double, Point<2, double> >(pts, param_nbsamples); writer.writePointset(pts); writer.close(); Results Dart Throwing Method ./bin/samplers/FastPoisson_2dd -o fastpoisson_1024.edat -n 1024 File fastpoisson_1024.edat Pointset Fourier ./bin/samplers/FastPoisson_2dd -o fastpoisson_4096.edat -n 4096 File fastpoisson_4096.edat Pointset Fourier ./bin/samplers/FastPoisson_2dd --minmaxthrows 50 -o fastpoisson_50_1024.edat -n 1024 File fastpoisson_50_1024.edat Pointset Fourier ./bin/samplers/FastPoisson_2dd --minmaxthrows 200 -o fastpoisson_200_1024.edat -n 1024 File fastpoisson_200_1024.edat Pointset Fourier ./bin/samplers/FastPoisson_2dd --mult 2 -o fastpoisson_mult2_1024.edat -n 1024 File fastpoisson_mult2_1024.edat Pointset Fourier Pure Method ./bin/samplers/FastPoisson_2dd --method Pure -o fastpoisson_Pure_1024.edat -n 1024 File fastpoisson_Pure_1024.edat Pointset Fourier ./bin/samplers/FastPoisson_2dd --method Pure -o fastpoisson_Pure_4096.edat -n 4096 File fastpoisson_Pure_4096.edat Pointset Fourier Linear Pure Method ./bin/samplers/FastPoisson_2dd --method LinearPure -o fastpoisson_LinearPure_1024.edat -n 1024 File fastpoisson_LinearPure_1024.edat Pointset Fourier ./bin/samplers/FastPoisson_2dd --method LinearPure -o fastpoisson_LinearPure_4096.edat -n 4096 File fastpoisson_LinearPure_4096.edat Pointset Fourier","title":"Fast Poisson"},{"location":"sampler_fastpoisson/#sampler-fast-poisson-bri07","text":"","title":"Sampler Fast Poisson [Bri07]"},{"location":"sampler_fastpoisson/#files","text":"src/samplers/SamplerFastPoisson.hpp src/bin/samplers/FastPoisson_2dd.cpp.cpp","title":"Files"},{"location":"sampler_fastpoisson/#description","text":"The Fast Poisson sampler from [DH06] . For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html .","title":"Description"},{"location":"sampler_fastpoisson/#license","text":"Public Domain: This code is released into the public domain. You can do whatever you want with it. I do ask that you respect the authorship and credit myself (Daniel Dunbar) when referencing the code. Additionally, if you use the code in an interesting or integral manner I would like to hear about it.","title":"License"},{"location":"sampler_fastpoisson/#execution","text":"Parameters: [HELP] -o [string = output_pts.dat] Output file -m [int = 1] Number of poinset realisations -n [ullint = 1024] Number of samples to generate --silent Silent mode -h Displays this help message --method [string = DartThrowing] The method to use to generate the samples (DartThrowing | Pure | LinearPure) --minmaxthrows [int = 100] set minimum number of maximum throws for DartThrowing sampler --mult [int = 1] set multiplier for DartThrowing sampler --tiled If set, use tiled domain To generate a 2D point set of 1024 samples with a fastpoisson distribution, we can use the following client line command: ./bin/samplers/FastPoisson_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter< 2, double, Point<2, double> > writer; writer.open(\"toto.dat\"); Pointset< 2, double, Point<2, double> > pts; SamplerFastPoisson s; unsigned int param_nbsamples = 1024; s.generateSamples< 2, double, Point<2, double> >(pts, param_nbsamples); writer.writePointset(pts); writer.close();","title":"Execution"},{"location":"sampler_fastpoisson/#results","text":"Dart Throwing Method ./bin/samplers/FastPoisson_2dd -o fastpoisson_1024.edat -n 1024 File fastpoisson_1024.edat Pointset Fourier ./bin/samplers/FastPoisson_2dd -o fastpoisson_4096.edat -n 4096 File fastpoisson_4096.edat Pointset Fourier ./bin/samplers/FastPoisson_2dd --minmaxthrows 50 -o fastpoisson_50_1024.edat -n 1024 File fastpoisson_50_1024.edat Pointset Fourier ./bin/samplers/FastPoisson_2dd --minmaxthrows 200 -o fastpoisson_200_1024.edat -n 1024 File fastpoisson_200_1024.edat Pointset Fourier ./bin/samplers/FastPoisson_2dd --mult 2 -o fastpoisson_mult2_1024.edat -n 1024 File fastpoisson_mult2_1024.edat Pointset Fourier Pure Method ./bin/samplers/FastPoisson_2dd --method Pure -o fastpoisson_Pure_1024.edat -n 1024 File fastpoisson_Pure_1024.edat Pointset Fourier ./bin/samplers/FastPoisson_2dd --method Pure -o fastpoisson_Pure_4096.edat -n 4096 File fastpoisson_Pure_4096.edat Pointset Fourier Linear Pure Method ./bin/samplers/FastPoisson_2dd --method LinearPure -o fastpoisson_LinearPure_1024.edat -n 1024 File fastpoisson_LinearPure_1024.edat Pointset Fourier ./bin/samplers/FastPoisson_2dd --method LinearPure -o fastpoisson_LinearPure_4096.edat -n 4096 File fastpoisson_LinearPure_4096.edat Pointset Fourier","title":"Results"},{"location":"sampler_faure/","text":"Sampler Faure [Fau82] Files src/samplers/SamplerFaure.hpp src/bin/samplers/Faure_2d*.cpp.cpp Description The Faure sequence (2D only). For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html . License GNU LGPL , code from https://people.sc.fsu.edu/~jburkardt/cpp_src/faure/faure.html Execution Parameters: [HELP] -o [string=output_pts.dat] Output file -m [int=1] Number of poinset realisations -n [ullint=1024] Number of samples to generate --silent Silent mode -h Displays this help message To generate a 2D point set of 1024 samples with a faure distribution, we can use the following client line command: ./bin/samplers/Faure_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter < 2 , double , Point < 2 , double > > writer ; writer . open ( \"toto.dat\" ); Pointset < 2 , double , Point < 2 , double > > pts ; SamplerFaure s ; unsigned int param_nbsamples = 1024 ; s . generateSamples < 2 , double , Point < 2 , double > > ( pts , param_nbsamples ); writer . writePointset ( pts ); writer . close (); Results ./bin/samplers/Faure_2dd -o faure_1024.edat -n 1024 File faure_1024.edat Pointset Fourier ./bin/samplers/Faure_2dd -o faure_4096.edat -n 4096 File faure_4096.edat Pointset Fourier","title":"Faure"},{"location":"sampler_faure/#sampler-faure-fau82","text":"","title":"Sampler Faure [Fau82]"},{"location":"sampler_faure/#files","text":"src/samplers/SamplerFaure.hpp src/bin/samplers/Faure_2d*.cpp.cpp","title":"Files"},{"location":"sampler_faure/#description","text":"The Faure sequence (2D only). For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html .","title":"Description"},{"location":"sampler_faure/#license","text":"GNU LGPL , code from https://people.sc.fsu.edu/~jburkardt/cpp_src/faure/faure.html","title":"License"},{"location":"sampler_faure/#execution","text":"Parameters: [HELP] -o [string=output_pts.dat] Output file -m [int=1] Number of poinset realisations -n [ullint=1024] Number of samples to generate --silent Silent mode -h Displays this help message To generate a 2D point set of 1024 samples with a faure distribution, we can use the following client line command: ./bin/samplers/Faure_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter < 2 , double , Point < 2 , double > > writer ; writer . open ( \"toto.dat\" ); Pointset < 2 , double , Point < 2 , double > > pts ; SamplerFaure s ; unsigned int param_nbsamples = 1024 ; s . generateSamples < 2 , double , Point < 2 , double > > ( pts , param_nbsamples ); writer . writePointset ( pts ); writer . close ();","title":"Execution"},{"location":"sampler_faure/#results","text":"./bin/samplers/Faure_2dd -o faure_1024.edat -n 1024","title":"Results"},{"location":"sampler_faure/#file","text":"faure_1024.edat","title":"File"},{"location":"sampler_faure/#pointset","text":"","title":"Pointset"},{"location":"sampler_faure/#fourier","text":"./bin/samplers/Faure_2dd -o faure_4096.edat -n 4096","title":"Fourier"},{"location":"sampler_faure/#file_1","text":"faure_4096.edat","title":"File"},{"location":"sampler_faure/#pointset_1","text":"","title":"Pointset"},{"location":"sampler_faure/#fourier_1","text":"","title":"Fourier"},{"location":"sampler_forced_random/","text":"Sampler Forced Random [CTS*17] Files src/samplers/SamplerForcedRandom.hpp src/bin/samplers/ForcedRandom_2dd.cpp.cpp Description A sampler based on dithering matrices from [CTS*17] . License Open Unlicense , see source code: This is free and unencumbered software released into the public domain. Anyone is free to copy, modify, publish, use, compile, sell, or distribute this software, either in source code form or as a compiled binary, for any purpose, commercial or non-commercial, and by any means. In jurisdictions that recognize copyright laws, the author or authors of this software dedicate any and all copyright interest in the software to the public domain. We make this dedication for the benefit of the public at large and to the detriment of our heirs and successors. We intend this dedication to be an overt act of relinquishment in perpetuity of all present and future rights to this software under copyright law. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. For more information, please refer to <http://unlicense.org/> Execution Parameters: [HELP] -o [string = output_pts.dat] Output file -m [int = 1] Number of poinset realisations -n [ullint = 1024] Number of samples to generate --silent Silent mode -h Displays this help message --matrix [int = 512] the matrix size [512 | 1024 | 2048] --sparsity [int = 8] the matrix sparsity To generate a 2D point set of 1024 samples with a forced_random distribution, we can use the following client line command: ./bin/samplers/ForcedRandom_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter< 2, double, Point<2, double> > writer; writer.open(\"toto.dat\"); Pointset< 2, double, Point<2, double> > pts; SamplerForcedRandom s; unsigned int param_nbsamples = 1024; s.generateSamples< 2, double, Point<2, double> >(pts, param_nbsamples); writer.writePointset(pts); writer.close(); Results ./bin/samplers/ForcedRandom_2dd -o forced_random_1024.edat -n 1024 File forced_random_1024.edat Pointset Fourier ./bin/samplers/ForcedRandom_2dd -o forced_random_4096.edat -n 4096 File forced_random_4096.edat Pointset Fourier","title":"Forced Random"},{"location":"sampler_forced_random/#sampler-forced-random-cts17","text":"","title":"Sampler Forced Random [CTS*17]"},{"location":"sampler_forced_random/#files","text":"src/samplers/SamplerForcedRandom.hpp src/bin/samplers/ForcedRandom_2dd.cpp.cpp","title":"Files"},{"location":"sampler_forced_random/#description","text":"A sampler based on dithering matrices from [CTS*17] .","title":"Description"},{"location":"sampler_forced_random/#license","text":"Open Unlicense , see source code: This is free and unencumbered software released into the public domain. Anyone is free to copy, modify, publish, use, compile, sell, or distribute this software, either in source code form or as a compiled binary, for any purpose, commercial or non-commercial, and by any means. In jurisdictions that recognize copyright laws, the author or authors of this software dedicate any and all copyright interest in the software to the public domain. We make this dedication for the benefit of the public at large and to the detriment of our heirs and successors. We intend this dedication to be an overt act of relinquishment in perpetuity of all present and future rights to this software under copyright law. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. For more information, please refer to <http://unlicense.org/>","title":"License"},{"location":"sampler_forced_random/#execution","text":"Parameters: [HELP] -o [string = output_pts.dat] Output file -m [int = 1] Number of poinset realisations -n [ullint = 1024] Number of samples to generate --silent Silent mode -h Displays this help message --matrix [int = 512] the matrix size [512 | 1024 | 2048] --sparsity [int = 8] the matrix sparsity To generate a 2D point set of 1024 samples with a forced_random distribution, we can use the following client line command: ./bin/samplers/ForcedRandom_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter< 2, double, Point<2, double> > writer; writer.open(\"toto.dat\"); Pointset< 2, double, Point<2, double> > pts; SamplerForcedRandom s; unsigned int param_nbsamples = 1024; s.generateSamples< 2, double, Point<2, double> >(pts, param_nbsamples); writer.writePointset(pts); writer.close();","title":"Execution"},{"location":"sampler_forced_random/#results","text":"./bin/samplers/ForcedRandom_2dd -o forced_random_1024.edat -n 1024 File forced_random_1024.edat Pointset Fourier ./bin/samplers/ForcedRandom_2dd -o forced_random_4096.edat -n 4096 File forced_random_4096.edat Pointset Fourier","title":"Results"},{"location":"sampler_genetic_owen/","text":"Sampler Genetic Owen Files src/samplers/SamplerGeneticOwen.hpp src/bin/samplers/GeneticOwen_2dd.cpp.cpp Description Owen\u2019s scrambling uses a permutation tree in each dimension. This tree is usually randomly filled. For a set containing n samples, it contains N flags, with N=n-1. This leads to 2^N 2^N possible trees in each dimension, which is too computationally expensive for an exhaustive search. This sampler thus uses genetic algorithms to try and find the best possible tree generating Blue Noise sets. However, the algorithm is too naive to generate good Blue Noise sets for more than 128 samples. License BSD, see SamplerGeneticOwen.hpp Execution Parameters: [HELP] -o [string=output_pts.dat] Output file -m [int=1] Number of poinset realisations -n [ullint=1024] Number of samples to generate --silent Silent mode -h Displays this help message --iter [int=1000] the number of iterations To generate a 2D point set of 1024 samples with a genetic_owen distribution, we can use the following client line command: ./bin/samplers/GeneticOwen_2dd --iter 200 -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter < 2 , double , Point < 2 , double > > writer ; writer . open ( \"toto.dat\" ); Pointset < 2 , double , Point < 2 , double > > pts ; SamplerGeneticOwen s ; unsigned int param_nbsamples = 1024 ; s . generateSamples < 2 , double , Point < 2 , double > > ( pts , param_nbsamples ); writer . writePointset ( pts ); writer . close (); Results ./bin/samplers/GeneticOwen_2dd --iter 200 -o genetic_owen_64.edat -n 64 File genetic_owen_64.edat Pointset Fourier ./bin/samplers/GeneticOwen_2dd --iter 200 -o genetic_owen_128.edat -n 128 File genetic_owen_128.edat Pointset Fourier","title":"Sampler Genetic Owen"},{"location":"sampler_genetic_owen/#sampler-genetic-owen","text":"","title":"Sampler Genetic Owen"},{"location":"sampler_genetic_owen/#files","text":"src/samplers/SamplerGeneticOwen.hpp src/bin/samplers/GeneticOwen_2dd.cpp.cpp","title":"Files"},{"location":"sampler_genetic_owen/#description","text":"Owen\u2019s scrambling uses a permutation tree in each dimension. This tree is usually randomly filled. For a set containing n samples, it contains N flags, with N=n-1. This leads to 2^N 2^N possible trees in each dimension, which is too computationally expensive for an exhaustive search. This sampler thus uses genetic algorithms to try and find the best possible tree generating Blue Noise sets. However, the algorithm is too naive to generate good Blue Noise sets for more than 128 samples.","title":"Description"},{"location":"sampler_genetic_owen/#license","text":"BSD, see SamplerGeneticOwen.hpp","title":"License"},{"location":"sampler_genetic_owen/#execution","text":"Parameters: [HELP] -o [string=output_pts.dat] Output file -m [int=1] Number of poinset realisations -n [ullint=1024] Number of samples to generate --silent Silent mode -h Displays this help message --iter [int=1000] the number of iterations To generate a 2D point set of 1024 samples with a genetic_owen distribution, we can use the following client line command: ./bin/samplers/GeneticOwen_2dd --iter 200 -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter < 2 , double , Point < 2 , double > > writer ; writer . open ( \"toto.dat\" ); Pointset < 2 , double , Point < 2 , double > > pts ; SamplerGeneticOwen s ; unsigned int param_nbsamples = 1024 ; s . generateSamples < 2 , double , Point < 2 , double > > ( pts , param_nbsamples ); writer . writePointset ( pts ); writer . close ();","title":"Execution"},{"location":"sampler_genetic_owen/#results","text":"./bin/samplers/GeneticOwen_2dd --iter 200 -o genetic_owen_64.edat -n 64 File genetic_owen_64.edat Pointset Fourier ./bin/samplers/GeneticOwen_2dd --iter 200 -o genetic_owen_128.edat -n 128 File genetic_owen_128.edat Pointset Fourier","title":"Results"},{"location":"sampler_gradient_descent/","text":"Sampler Gradient Descent Files src/samplers/SamplerGradientDescent.hpp src/bin/samplers/GradientDescent_2dd.cpp.cpp Description This sampler optimizes a given input sampler to minimize its Generalized L2 discrepancy, using gradient descent. This optimizing is very slow and therefore can hardly be performed on more than 4k samples. License BSD, see SamplerGradientDescent.hpp Execution Parameters: [HELP] -o [string=output_pts.dat] Output file -m [int=1] Number of poinset realisations -n [ullint=1024] Number of samples to generate --silent Silent mode -h Displays this help message -i [string] The pointset to optimize To optimize the discrepancy of a 2D point set using gradient descent, we can use the following client line command: ./bin/samplers/GradientDescent_2dd -i bnot128.dat -o toto.dat Or one can use the following C++ code: PointsetWriter < 2 , double , Point < 2 , double > > writer ; writer . open ( \"toto.dat\" ); Pointset < 2 , double , Point < 2 , double > > pts ; SamplerGradientDescent s ; s . setInputPointset ( \"bnot128.dat\" ); s . generateSamples < 2 , double , Point < 2 , double > > ( pts ); writer . writePointset ( pts ); writer . close (); Results ./bin/samplers/GradientDescent_2dd -i bnot128.dat -o optimbnot_128.edat Initial File bnot128.dat Initial Pointset Initial Fourier Optimized File optimbnot_128.edat Optimized Pointset Optimized Fourier ./bin/samplers/GradientDescent_2dd -i bnot1024.dat -o optimbnot_1024.edat Initial File bnot1024.dat Initial Pointset Initial Fourier Optimized File optimbnot_1024.edat Optimized Pointset Optimized Fourier Discrepancy Graph","title":"Sampler Gradient Descent"},{"location":"sampler_gradient_descent/#sampler-gradient-descent","text":"","title":"Sampler Gradient Descent"},{"location":"sampler_gradient_descent/#files","text":"src/samplers/SamplerGradientDescent.hpp src/bin/samplers/GradientDescent_2dd.cpp.cpp","title":"Files"},{"location":"sampler_gradient_descent/#description","text":"This sampler optimizes a given input sampler to minimize its Generalized L2 discrepancy, using gradient descent. This optimizing is very slow and therefore can hardly be performed on more than 4k samples.","title":"Description"},{"location":"sampler_gradient_descent/#license","text":"BSD, see SamplerGradientDescent.hpp","title":"License"},{"location":"sampler_gradient_descent/#execution","text":"Parameters: [HELP] -o [string=output_pts.dat] Output file -m [int=1] Number of poinset realisations -n [ullint=1024] Number of samples to generate --silent Silent mode -h Displays this help message -i [string] The pointset to optimize To optimize the discrepancy of a 2D point set using gradient descent, we can use the following client line command: ./bin/samplers/GradientDescent_2dd -i bnot128.dat -o toto.dat Or one can use the following C++ code: PointsetWriter < 2 , double , Point < 2 , double > > writer ; writer . open ( \"toto.dat\" ); Pointset < 2 , double , Point < 2 , double > > pts ; SamplerGradientDescent s ; s . setInputPointset ( \"bnot128.dat\" ); s . generateSamples < 2 , double , Point < 2 , double > > ( pts ); writer . writePointset ( pts ); writer . close ();","title":"Execution"},{"location":"sampler_gradient_descent/#results","text":"./bin/samplers/GradientDescent_2dd -i bnot128.dat -o optimbnot_128.edat Initial File bnot128.dat Initial Pointset Initial Fourier Optimized File optimbnot_128.edat Optimized Pointset Optimized Fourier ./bin/samplers/GradientDescent_2dd -i bnot1024.dat -o optimbnot_1024.edat Initial File bnot1024.dat Initial Pointset Initial Fourier Optimized File optimbnot_1024.edat Optimized Pointset Optimized Fourier Discrepancy Graph","title":"Results"},{"location":"sampler_halton/","text":"Sampler Halton [Hal64] Files src/samplers/SamplerHalton.hpp src/bin/samplers/Halton_*d*.cpp Description The Halton sequence. Samples are generated from reversing the n-ary representation of their index. Each dimension has a different basis and the low discrepancy is ensured if all basis are distinct and are prime numbers. For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html . License BSD license, see the SamplerHalton.hpp file. Execution Parameters: [HELP] -o [string=output_pts.dat] Output file -m [int=1] Number of poinset realisations -n [ullint=1024] Number of samples to generate --silent Silent mode -h Displays this help message -x [uint=2] the basis for the first dimension -y [uint=3] the basis for the second dimension To generate a 2D point set of 1024 samples with a halton distribution, we can use the following client line command: ./bin/samplers/Halton_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter < 2 , double , Point < 2 , double > > writer ; writer . open ( \"toto.dat\" ); Pointset < 2 , double , Point < 2 , double > > pts ; SamplerHalton s ; unsigned int param_nbsamples = 1024 ; unsigned int bases [ 2 ] = { 2 , 3 }; s . setBaseList ( & bases [ 0 ], 2 ); s . generateSamples < 2 , double , Point < 2 , double > > ( pts , param_nbsamples ); writer . writePointset ( pts ); writer . close (); Results ./bin/samplers/Halton_2dd -o halton_1024.edat -n 1024 File halton_1024.edat Pointset Fourier ./bin/samplers/Halton_2dd -o halton_4096.edat -n 4096 File halton_4096.edat Pointset Fourier ./bin/samplers/Halton_2dd -x 5 -y 7 -o halton_57_1024.edat -n 1024 File halton_57_1024.edat Pointset Fourier When the basis are not relatively prime, the low discrepancy property is broken. ./bin/samplers/Halton_2dd -x 3 -y 6 -o halton_36_1024.edat -n 1024 File halton_36 _1024.edat Pointset Fourier","title":"Halton"},{"location":"sampler_halton/#sampler-halton-hal64","text":"","title":"Sampler Halton [Hal64]"},{"location":"sampler_halton/#files","text":"src/samplers/SamplerHalton.hpp src/bin/samplers/Halton_*d*.cpp","title":"Files"},{"location":"sampler_halton/#description","text":"The Halton sequence. Samples are generated from reversing the n-ary representation of their index. Each dimension has a different basis and the low discrepancy is ensured if all basis are distinct and are prime numbers. For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html .","title":"Description"},{"location":"sampler_halton/#license","text":"BSD license, see the SamplerHalton.hpp file.","title":"License"},{"location":"sampler_halton/#execution","text":"Parameters: [HELP] -o [string=output_pts.dat] Output file -m [int=1] Number of poinset realisations -n [ullint=1024] Number of samples to generate --silent Silent mode -h Displays this help message -x [uint=2] the basis for the first dimension -y [uint=3] the basis for the second dimension To generate a 2D point set of 1024 samples with a halton distribution, we can use the following client line command: ./bin/samplers/Halton_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter < 2 , double , Point < 2 , double > > writer ; writer . open ( \"toto.dat\" ); Pointset < 2 , double , Point < 2 , double > > pts ; SamplerHalton s ; unsigned int param_nbsamples = 1024 ; unsigned int bases [ 2 ] = { 2 , 3 }; s . setBaseList ( & bases [ 0 ], 2 ); s . generateSamples < 2 , double , Point < 2 , double > > ( pts , param_nbsamples ); writer . writePointset ( pts ); writer . close ();","title":"Execution"},{"location":"sampler_halton/#results","text":"./bin/samplers/Halton_2dd -o halton_1024.edat -n 1024 File halton_1024.edat Pointset Fourier ./bin/samplers/Halton_2dd -o halton_4096.edat -n 4096 File halton_4096.edat Pointset Fourier ./bin/samplers/Halton_2dd -x 5 -y 7 -o halton_57_1024.edat -n 1024 File halton_57_1024.edat Pointset Fourier When the basis are not relatively prime, the low discrepancy property is broken. ./bin/samplers/Halton_2dd -x 3 -y 6 -o halton_36_1024.edat -n 1024 File halton_36 _1024.edat Pointset Fourier","title":"Results"},{"location":"sampler_hammersley/","text":"Sampler Hammersley [Ham60] Files src/samplers/SamplerHammersley.hpp src/bin/samplers/Hammersley_2d*.cpp Description The Hammersley sampler. This sampler is only 2D, with the first coordinate obtained by dividing the index of the sample by the total number of samples, and the second coordinate obtained by reversing the binary representation of the index. For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html . License BSD, see SamplerHammersley.hpp . Execution Parameters: [HELP] -o [string=output_pts.dat] Output file -m [int=1] Number of poinset realisations -n [ullint=1024] Number of samples to generate --silent Silent mode -h Displays this help message To generate a 2D point set of 1024 samples with a hammersley distribution, we can use the following client line command: ./bin/samplers/Hammersley_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter < 2 , double , Point < 2 , double > > writer ; writer . open ( \"toto.dat\" ); Pointset < 2 , double , Point < 2 , double > > pts ; SamplerHammersley s ; unsigned int param_nbsamples = 1024 ; s . generateSamples < 2 , double , Point < 2 , double > > ( pts , param_nbsamples ); writer . writePointset ( pts ); writer . close (); Results ./bin/samplers/Hammersley_2dd -o hammersley_1024.edat -n 1024 File hammersley_1024.edat Pointset Fourier ./bin/samplers/Hammersley_2dd -o hammersley_4096.edat -n 4096 File hammersley_4096.edat Pointset Fourier","title":"Hammersley"},{"location":"sampler_hammersley/#sampler-hammersley-ham60","text":"","title":"Sampler Hammersley [Ham60]"},{"location":"sampler_hammersley/#files","text":"src/samplers/SamplerHammersley.hpp src/bin/samplers/Hammersley_2d*.cpp","title":"Files"},{"location":"sampler_hammersley/#description","text":"The Hammersley sampler. This sampler is only 2D, with the first coordinate obtained by dividing the index of the sample by the total number of samples, and the second coordinate obtained by reversing the binary representation of the index. For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html .","title":"Description"},{"location":"sampler_hammersley/#license","text":"BSD, see SamplerHammersley.hpp .","title":"License"},{"location":"sampler_hammersley/#execution","text":"Parameters: [HELP] -o [string=output_pts.dat] Output file -m [int=1] Number of poinset realisations -n [ullint=1024] Number of samples to generate --silent Silent mode -h Displays this help message To generate a 2D point set of 1024 samples with a hammersley distribution, we can use the following client line command: ./bin/samplers/Hammersley_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter < 2 , double , Point < 2 , double > > writer ; writer . open ( \"toto.dat\" ); Pointset < 2 , double , Point < 2 , double > > pts ; SamplerHammersley s ; unsigned int param_nbsamples = 1024 ; s . generateSamples < 2 , double , Point < 2 , double > > ( pts , param_nbsamples ); writer . writePointset ( pts ); writer . close ();","title":"Execution"},{"location":"sampler_hammersley/#results","text":"./bin/samplers/Hammersley_2dd -o hammersley_1024.edat -n 1024 File hammersley_1024.edat Pointset Fourier ./bin/samplers/Hammersley_2dd -o hammersley_4096.edat -n 4096 File hammersley_4096.edat Pointset Fourier","title":"Results"},{"location":"sampler_hexagonal_grid/","text":"Sampler Hexagonal Grid Files src/samplers/SamplerHexagonalGrid.hpp src/bin/samplers/HexagonalGrid_2dd.cpp Description An hexagonal grid. For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html . License BSD, see SamplerHexagonalGrid.hpp Execution Parameters: [HELP] -o [string = output_pts.dat] Output file -m [int = 1] Number of poinset realisations -n [ullint = 1024] Number of samples to generate --silent Silent mode -h Displays this help message To generate a 2D point set of 1024 samples with a hexagonal_grid distribution, we can use the following client line command: ./bin/samplers/HexagonalGrid_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter< 2, double, Point<2, double> > writer; writer.open(\"toto.dat\"); Pointset< 2, double, Point<2, double> > pts; SamplerHexagonalGrid s; unsigned int param_nbsamples = 1024; s.generateSamples< 2, double, Point<2, double> >(pts, param_nbsamples); writer.writePointset(pts); writer.close(); Results ./bin/samplers/HexagonalGrid_2dd -o hexagonal_grid_1024.edat -n 1024 File hexagonal_grid_1024.edat Pointset Fourier ./bin/samplers/HexagonalGrid_2dd -o hexagonal_grid_4096.edat -n 4096 File hexagonal_grid_4096.edat Pointset Fourier","title":"Hexagonal grid"},{"location":"sampler_hexagonal_grid/#sampler-hexagonal-grid","text":"","title":"Sampler Hexagonal Grid"},{"location":"sampler_hexagonal_grid/#files","text":"src/samplers/SamplerHexagonalGrid.hpp src/bin/samplers/HexagonalGrid_2dd.cpp","title":"Files"},{"location":"sampler_hexagonal_grid/#description","text":"An hexagonal grid. For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html .","title":"Description"},{"location":"sampler_hexagonal_grid/#license","text":"BSD, see SamplerHexagonalGrid.hpp","title":"License"},{"location":"sampler_hexagonal_grid/#execution","text":"Parameters: [HELP] -o [string = output_pts.dat] Output file -m [int = 1] Number of poinset realisations -n [ullint = 1024] Number of samples to generate --silent Silent mode -h Displays this help message To generate a 2D point set of 1024 samples with a hexagonal_grid distribution, we can use the following client line command: ./bin/samplers/HexagonalGrid_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter< 2, double, Point<2, double> > writer; writer.open(\"toto.dat\"); Pointset< 2, double, Point<2, double> > pts; SamplerHexagonalGrid s; unsigned int param_nbsamples = 1024; s.generateSamples< 2, double, Point<2, double> >(pts, param_nbsamples); writer.writePointset(pts); writer.close();","title":"Execution"},{"location":"sampler_hexagonal_grid/#results","text":"./bin/samplers/HexagonalGrid_2dd -o hexagonal_grid_1024.edat -n 1024 File hexagonal_grid_1024.edat Pointset Fourier ./bin/samplers/HexagonalGrid_2dd -o hexagonal_grid_4096.edat -n 4096 File hexagonal_grid_4096.edat Pointset Fourier","title":"Results"},{"location":"sampler_korobov/","text":"Sampler Korobov [Kor59] Files src/samplers/SamplerKorobov.hpp src/bin/samplers/Korobov_2dd.cpp Description Korobov lattices. The generator value should be prime relatively to the number of samples, otherwise the point set will not be projection regular. For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html . Execution Parameters: [HELP] -o [string = output_pts.dat] Output file -m [int = 1] Number of poinset realisations -n [ullint = 1024] Number of samples to generate --silent Silent mode -h Displays this help message -a [uint = 3] The generator value To generate a 2D point set of 1024 samples with a korobov distribution, we can use the following client line command: ./bin/samplers/Korobov_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter< 2, double, Point<2, double> > writer; writer.open(\"toto.dat\"); Pointset< 2, double, Point<2, double> > pts; SamplerKorobov s; unsigned int param_nbsamples = 1024; s.generateSamples< 2, double, Point<2, double> >(pts, param_nbsamples); writer.writePointset(pts); writer.close(); Results ./bin/samplers/Korobov_2dd -o korobov_1024.edat -n 1024 File korobov_1024.edat Pointset Fourier ./bin/samplers/Korobov_2dd -o korobov_4096.edat -n 4096 File korobov_4096.edat Pointset Fourier ./bin/samplers/Korobov_2dd -a 89 -o korobov_89_1024.edat -n 1024 File korobov_89_1024.edat Pointset Fourier ./bin/samplers/Korobov_2dd -a 419 -o korobov_419_1024.edat -n 1024 File korobov_419_1024.edat Pointset Fourier ./bin/samplers/Korobov_2dd -a 787 -o korobov_787_1024.edat -n 1024 File korobov_787_1024.edat Pointset Fourier ./bin/samplers/Korobov_2dd -a 2659 -o korobov_2659_1024.edat -n 1024 File korobov_2659_1024.edat Pointset Fourier","title":"Korobov"},{"location":"sampler_korobov/#sampler-korobov-kor59","text":"","title":"Sampler Korobov [Kor59]"},{"location":"sampler_korobov/#files","text":"src/samplers/SamplerKorobov.hpp src/bin/samplers/Korobov_2dd.cpp","title":"Files"},{"location":"sampler_korobov/#description","text":"Korobov lattices. The generator value should be prime relatively to the number of samples, otherwise the point set will not be projection regular. For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html .","title":"Description"},{"location":"sampler_korobov/#execution","text":"Parameters: [HELP] -o [string = output_pts.dat] Output file -m [int = 1] Number of poinset realisations -n [ullint = 1024] Number of samples to generate --silent Silent mode -h Displays this help message -a [uint = 3] The generator value To generate a 2D point set of 1024 samples with a korobov distribution, we can use the following client line command: ./bin/samplers/Korobov_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter< 2, double, Point<2, double> > writer; writer.open(\"toto.dat\"); Pointset< 2, double, Point<2, double> > pts; SamplerKorobov s; unsigned int param_nbsamples = 1024; s.generateSamples< 2, double, Point<2, double> >(pts, param_nbsamples); writer.writePointset(pts); writer.close();","title":"Execution"},{"location":"sampler_korobov/#results","text":"./bin/samplers/Korobov_2dd -o korobov_1024.edat -n 1024 File korobov_1024.edat Pointset Fourier ./bin/samplers/Korobov_2dd -o korobov_4096.edat -n 4096 File korobov_4096.edat Pointset Fourier ./bin/samplers/Korobov_2dd -a 89 -o korobov_89_1024.edat -n 1024 File korobov_89_1024.edat Pointset Fourier ./bin/samplers/Korobov_2dd -a 419 -o korobov_419_1024.edat -n 1024 File korobov_419_1024.edat Pointset Fourier ./bin/samplers/Korobov_2dd -a 787 -o korobov_787_1024.edat -n 1024 File korobov_787_1024.edat Pointset Fourier ./bin/samplers/Korobov_2dd -a 2659 -o korobov_2659_1024.edat -n 1024 File korobov_2659_1024.edat Pointset Fourier","title":"Results"},{"location":"sampler_ldbn/","text":"Sampler LDBN [APC*16] Files src/samplers/SamplerLDBN.hpp src/bin/samplers/LDBN_2dd.cpp Description The LDBN sampler from [APC*16] . This sampler is only 2D. For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html . License BSD, see SamplerLDBN.hpp . Execution Parameters: [HELP] -o [string=output_pts.dat] Output file -m [int=1] Number of poinset realisations -n [ullint=1024] Number of samples to generate --silent Silent mode -h Displays this help message -d [string] File containing the permutations -t [uint=128] The size of the permutation tile -c [uint=16] The size of the permutation chunk To generate a 2D point set of 1024 samples with a ldbn distribution, we can use the following client line command: ./bin/samplers/LDBN_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter < 2 , double , Point < 2 , double > > writer ; writer . open ( \"toto.dat\" ); Pointset < 2 , double , Point < 2 , double > > pts ; SamplerLDBN s ; unsigned int param_nbsamples = 1024 ; s . generateSamples < 2 , double , Point < 2 , double > > ( pts , param_nbsamples ); writer . writePointset ( pts ); writer . close (); Results ./bin/samplers/LDBN_2dd -o ldbn_1024.edat -n 1024 File ldbn_1024.edat Pointset Fourier ./bin/samplers/LDBN_2dd -o ldbn_4096.edat -n 4096 File ldbn_4096.edat Pointset Fourier Changing the chunk size affects the Blue Noise property of the final set ./bin/samplers/LDBN_2dd -t 128 -c 1 -o ldbn_128_1_1024.edat -n 1024 File ldbn_128_1_1024.edat Pointset Fourier ./bin/samplers/LDBN_2dd -t 128 -c 4 -o ldbn_128_4_1024.edat -n 1024 File ldbn_128_4_1024.edat Pointset Fourier ./bin/samplers/LDBN_2dd -t 128 -c 8 -o ldbn_128_8_1024.edat -n 1024 File ldbn_128_8_1024.edat Pointset Fourier ./bin/samplers/LDBN_2dd -t 128 -c 32 -o ldbn_128_32_1024.edat -n 1024 File ldbn_128_32_1024.edat Pointset Fourier ./bin/samplers/LDBN_2dd -t 128 -c 64 -o ldbn_128_64_1024.edat -n 1024 File ldbn_128_64_1024.edat Pointset Fourier One can also change the final spectrum to generate a step disctribution instead. ./bin/samplers/LDBN_2dd -t 128 -c 16 -o ldbn_step_1024.edat -n 1024 -d ../../data/LDBN/tables_Step/tilesize_128/chunksize_m016.dat File ldbn_step_1024.edat Pointset Fourier","title":"LDBN"},{"location":"sampler_ldbn/#sampler-ldbn-apc16","text":"","title":"Sampler LDBN [APC*16]"},{"location":"sampler_ldbn/#files","text":"src/samplers/SamplerLDBN.hpp src/bin/samplers/LDBN_2dd.cpp","title":"Files"},{"location":"sampler_ldbn/#description","text":"The LDBN sampler from [APC*16] . This sampler is only 2D. For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html .","title":"Description"},{"location":"sampler_ldbn/#license","text":"BSD, see SamplerLDBN.hpp .","title":"License"},{"location":"sampler_ldbn/#execution","text":"Parameters: [HELP] -o [string=output_pts.dat] Output file -m [int=1] Number of poinset realisations -n [ullint=1024] Number of samples to generate --silent Silent mode -h Displays this help message -d [string] File containing the permutations -t [uint=128] The size of the permutation tile -c [uint=16] The size of the permutation chunk To generate a 2D point set of 1024 samples with a ldbn distribution, we can use the following client line command: ./bin/samplers/LDBN_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter < 2 , double , Point < 2 , double > > writer ; writer . open ( \"toto.dat\" ); Pointset < 2 , double , Point < 2 , double > > pts ; SamplerLDBN s ; unsigned int param_nbsamples = 1024 ; s . generateSamples < 2 , double , Point < 2 , double > > ( pts , param_nbsamples ); writer . writePointset ( pts ); writer . close ();","title":"Execution"},{"location":"sampler_ldbn/#results","text":"./bin/samplers/LDBN_2dd -o ldbn_1024.edat -n 1024 File ldbn_1024.edat Pointset Fourier ./bin/samplers/LDBN_2dd -o ldbn_4096.edat -n 4096 File ldbn_4096.edat Pointset Fourier Changing the chunk size affects the Blue Noise property of the final set ./bin/samplers/LDBN_2dd -t 128 -c 1 -o ldbn_128_1_1024.edat -n 1024 File ldbn_128_1_1024.edat Pointset Fourier ./bin/samplers/LDBN_2dd -t 128 -c 4 -o ldbn_128_4_1024.edat -n 1024 File ldbn_128_4_1024.edat Pointset Fourier ./bin/samplers/LDBN_2dd -t 128 -c 8 -o ldbn_128_8_1024.edat -n 1024 File ldbn_128_8_1024.edat Pointset Fourier ./bin/samplers/LDBN_2dd -t 128 -c 32 -o ldbn_128_32_1024.edat -n 1024 File ldbn_128_32_1024.edat Pointset Fourier ./bin/samplers/LDBN_2dd -t 128 -c 64 -o ldbn_128_64_1024.edat -n 1024 File ldbn_128_64_1024.edat Pointset Fourier One can also change the final spectrum to generate a step disctribution instead. ./bin/samplers/LDBN_2dd -t 128 -c 16 -o ldbn_step_1024.edat -n 1024 -d ../../data/LDBN/tables_Step/tilesize_128/chunksize_m016.dat File ldbn_step_1024.edat Pointset Fourier","title":"Results"},{"location":"sampler_lowdisc/","text":"Low Discrepancy Samplers Faure Halton Hammersley LDBN Projection scrambling Niederreiter Owen Sobol (code from [JK03] ) Sobol (Original)","title":"Sampler lowdisc"},{"location":"sampler_multijitter/","text":"Sampler Multi Jittered [CSW94] Files src/samplers/SamplerMultiJitter.hpp src/bin/samplers/MultiJitter_2dd.cpp Description The Multi-Jitter sampler from [CSW94] . For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html . Execution Parameters: [HELP] -o [string = output_pts.dat] Output file -m [int = 1] Number of poinset realisations -n [ullint = 1024] Number of samples to generate --silent Silent mode -h Displays this help message To generate a 2D point set of 1024 samples with a multijitter distribution, we can use the following client line command: ./bin/samplers/MultiJitter_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter< 2, double, Point<2, double> > writer; writer.open(\"toto.dat\"); Pointset< 2, double, Point<2, double> > pts; SamplerMultiJitter s; unsigned int param_nbsamples = 1024; s.generateSamples< 2, double, Point<2, double> >(pts, param_nbsamples); writer.writePointset(pts); writer.close(); Results ./bin/samplers/MultiJitter_2dd -o multijitter_1024.edat -n 1024 File multijitter_1024.edat Pointset Fourier ./bin/samplers/MultiJitter_2dd -o multijitter_4096.edat -n 4096 File multijitter_4096.edat Pointset Fourier","title":"Sampler Multi Jittered [[CSW94]](https://dl.acm.org/citation.cfm?id=180895.180927)"},{"location":"sampler_multijitter/#sampler-multi-jittered-csw94","text":"","title":"Sampler Multi Jittered [CSW94]"},{"location":"sampler_multijitter/#files","text":"src/samplers/SamplerMultiJitter.hpp src/bin/samplers/MultiJitter_2dd.cpp","title":"Files"},{"location":"sampler_multijitter/#description","text":"The Multi-Jitter sampler from [CSW94] . For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html .","title":"Description"},{"location":"sampler_multijitter/#execution","text":"Parameters: [HELP] -o [string = output_pts.dat] Output file -m [int = 1] Number of poinset realisations -n [ullint = 1024] Number of samples to generate --silent Silent mode -h Displays this help message To generate a 2D point set of 1024 samples with a multijitter distribution, we can use the following client line command: ./bin/samplers/MultiJitter_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter< 2, double, Point<2, double> > writer; writer.open(\"toto.dat\"); Pointset< 2, double, Point<2, double> > pts; SamplerMultiJitter s; unsigned int param_nbsamples = 1024; s.generateSamples< 2, double, Point<2, double> >(pts, param_nbsamples); writer.writePointset(pts); writer.close();","title":"Execution"},{"location":"sampler_multijitter/#results","text":"./bin/samplers/MultiJitter_2dd -o multijitter_1024.edat -n 1024 File multijitter_1024.edat Pointset Fourier ./bin/samplers/MultiJitter_2dd -o multijitter_4096.edat -n 4096 File multijitter_4096.edat Pointset Fourier","title":"Results"},{"location":"sampler_niederreiter/","text":"Sampler Niederreiter [Nie88] Files src/samplers/SamplerNiederreiter.hpp src/bin/samplers/Niederreiter_*dd.cpp.cpp Description The Niederreiter sequence. For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html . License GNU LGPL, code from https://people.sc.fsu.edu/~jburkardt/cpp_src/niederreiter2/niederreiter2.html Execution Parameters: [HELP] -o [string=output_pts.dat] Output file -m [int=1] Number of poinset realisations -n [ullint=1024] Number of samples to generate --silent Silent mode -h Displays this help message -b [uint=2] Basis To generate a 2D point set of 1024 samples with a nieddereiter distribution, we can use the following client line command: ./bin/samplers/Niederreiter_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter < 2 , double , Point < 2 , double > > writer ; writer . open ( \"toto.dat\" ); Pointset < 2 , double , Point < 2 , double > > pts ; SamplerNiederreiter s ; unsigned int param_nbsamples = 1024 ; s . generateSamples < 2 , double , Point < 2 , double > > ( pts , param_nbsamples ); writer . writePointset ( pts ); writer . close (); Results ./bin/samplers/Niederreiter_2dd -o nieddereiter_1024.edat -n 1024 File nieddereiter_1024.edat Pointset Fourier ./bin/samplers/Niederreiter_2dd -o nieddereiter_4096.edat -n 4096 File nieddereiter_4096.edat Pointset Fourier ./bin/samplers/Niederreiter_2dd -b 3 -o nieddereiter_b3_1024.edat -n 1024 File nieddereiter_b3_1024.edat Pointset Fourier ./bin/samplers/Niederreiter_2dd -b 5 -o nieddereiter_b5_1024.edat -n 1024 File nieddereiter_b5_1024.edat Pointset Fourier","title":"Niederreiter"},{"location":"sampler_niederreiter/#sampler-niederreiter-nie88","text":"","title":"Sampler Niederreiter [Nie88]"},{"location":"sampler_niederreiter/#files","text":"src/samplers/SamplerNiederreiter.hpp src/bin/samplers/Niederreiter_*dd.cpp.cpp","title":"Files"},{"location":"sampler_niederreiter/#description","text":"The Niederreiter sequence. For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html .","title":"Description"},{"location":"sampler_niederreiter/#license","text":"GNU LGPL, code from https://people.sc.fsu.edu/~jburkardt/cpp_src/niederreiter2/niederreiter2.html","title":"License"},{"location":"sampler_niederreiter/#execution","text":"Parameters: [HELP] -o [string=output_pts.dat] Output file -m [int=1] Number of poinset realisations -n [ullint=1024] Number of samples to generate --silent Silent mode -h Displays this help message -b [uint=2] Basis To generate a 2D point set of 1024 samples with a nieddereiter distribution, we can use the following client line command: ./bin/samplers/Niederreiter_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter < 2 , double , Point < 2 , double > > writer ; writer . open ( \"toto.dat\" ); Pointset < 2 , double , Point < 2 , double > > pts ; SamplerNiederreiter s ; unsigned int param_nbsamples = 1024 ; s . generateSamples < 2 , double , Point < 2 , double > > ( pts , param_nbsamples ); writer . writePointset ( pts ); writer . close ();","title":"Execution"},{"location":"sampler_niederreiter/#results","text":"./bin/samplers/Niederreiter_2dd -o nieddereiter_1024.edat -n 1024 File nieddereiter_1024.edat Pointset Fourier ./bin/samplers/Niederreiter_2dd -o nieddereiter_4096.edat -n 4096 File nieddereiter_4096.edat Pointset Fourier ./bin/samplers/Niederreiter_2dd -b 3 -o nieddereiter_b3_1024.edat -n 1024 File nieddereiter_b3_1024.edat Pointset Fourier ./bin/samplers/Niederreiter_2dd -b 5 -o nieddereiter_b5_1024.edat -n 1024 File nieddereiter_b5_1024.edat Pointset Fourier","title":"Results"},{"location":"sampler_nrooks/","text":"Sampler N-Rooks [Shi91] Files src/samplers/SamplerNRooks.hpp src/bin/samplers/NRooks_*dd.cpp.cpp Description The N-Rooks sampler. For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html . License BSD, see SamplerNRooks.hpp Execution Parameters: [HELP] -o [string = output_pts.dat] Output file -m [int = 1] Number of poinset realisations -n [ullint = 1024] Number of samples to generate --silent Silent mode -h Displays this help message To generate a 2D point set of 1024 samples with a nrooks distribution, we can use the following client line command: ./bin/samplers/NRooks_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter< 2, double, Point<2, double> > writer; writer.open(\"toto.dat\"); Pointset< 2, double, Point<2, double> > pts; SamplerNRooks s; unsigned int param_nbsamples = 1024; s.generateSamples< 2, double, Point<2, double> >(pts, param_nbsamples); writer.writePointset(pts); writer.close(); Results ./bin/samplers/NRooks_2dd -o nrooks_1024.edat -n 1024 File nrooks_1024.edat Pointset Fourier ./bin/samplers/NRooks_2dd -o nrooks_4096.edat -n 4096 File nrooks_4096.edat Pointset Fourier","title":"NRooks"},{"location":"sampler_nrooks/#sampler-n-rooks-shi91","text":"","title":"Sampler N-Rooks [Shi91]"},{"location":"sampler_nrooks/#files","text":"src/samplers/SamplerNRooks.hpp src/bin/samplers/NRooks_*dd.cpp.cpp","title":"Files"},{"location":"sampler_nrooks/#description","text":"The N-Rooks sampler. For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html .","title":"Description"},{"location":"sampler_nrooks/#license","text":"BSD, see SamplerNRooks.hpp","title":"License"},{"location":"sampler_nrooks/#execution","text":"Parameters: [HELP] -o [string = output_pts.dat] Output file -m [int = 1] Number of poinset realisations -n [ullint = 1024] Number of samples to generate --silent Silent mode -h Displays this help message To generate a 2D point set of 1024 samples with a nrooks distribution, we can use the following client line command: ./bin/samplers/NRooks_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter< 2, double, Point<2, double> > writer; writer.open(\"toto.dat\"); Pointset< 2, double, Point<2, double> > pts; SamplerNRooks s; unsigned int param_nbsamples = 1024; s.generateSamples< 2, double, Point<2, double> >(pts, param_nbsamples); writer.writePointset(pts); writer.close();","title":"Execution"},{"location":"sampler_nrooks/#results","text":"./bin/samplers/NRooks_2dd -o nrooks_1024.edat -n 1024 File nrooks_1024.edat Pointset Fourier ./bin/samplers/NRooks_2dd -o nrooks_4096.edat -n 4096 File nrooks_4096.edat Pointset Fourier","title":"Results"},{"location":"sampler_other/","text":"Other Samplers CMJ Hexagonal Grid Korobov NRooks Rank 1 Regular Grid Single Peak Step Stratified Whitenoise","title":"Sampler other"},{"location":"sampler_owen/","text":"Sampler Owen [Owe95] Files src/samplers/SamplerOwenSobol.hpp src/bin/samplers/Owen_*d*.cpp.cpp Description Owen\u2019s scrambling of the Sobol sequence. For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html . License BSD, see SamplerOwenSobol.hpp . Execution Parameters: [HELP] -o [string=output_pts.dat] Output file -m [int=1] Number of poinset realisations -n [ullint=1024] Number of samples to generate --silent Silent mode -h Displays this help message To generate a 2D point set of 1024 samples with a owen distribution, we can use the following client line command: ./bin/samplers/Owen_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter < 2 , double , Point < 2 , double > > writer ; writer . open ( \"toto.dat\" ); Pointset < 2 , double , Point < 2 , double > > pts ; SamplerOwen s ; unsigned int param_nbsamples = 1024 ; s . generateSamples < 2 , double , Point < 2 , double > > ( pts , param_nbsamples ); writer . writePointset ( pts ); writer . close (); Results ./bin/samplers/Owen_2dd -o owen_1024.edat -n 1024 File owen_1024.edat Pointset Fourier ./bin/samplers/Owen_2dd -o owen_4096.edat -n 4096 File owen_4096.edat Pointset Fourier","title":"Owen Scrambled Sobol"},{"location":"sampler_owen/#sampler-owen-owe95","text":"","title":"Sampler Owen [Owe95]"},{"location":"sampler_owen/#files","text":"src/samplers/SamplerOwenSobol.hpp src/bin/samplers/Owen_*d*.cpp.cpp","title":"Files"},{"location":"sampler_owen/#description","text":"Owen\u2019s scrambling of the Sobol sequence. For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html .","title":"Description"},{"location":"sampler_owen/#license","text":"BSD, see SamplerOwenSobol.hpp .","title":"License"},{"location":"sampler_owen/#execution","text":"Parameters: [HELP] -o [string=output_pts.dat] Output file -m [int=1] Number of poinset realisations -n [ullint=1024] Number of samples to generate --silent Silent mode -h Displays this help message To generate a 2D point set of 1024 samples with a owen distribution, we can use the following client line command: ./bin/samplers/Owen_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter < 2 , double , Point < 2 , double > > writer ; writer . open ( \"toto.dat\" ); Pointset < 2 , double , Point < 2 , double > > pts ; SamplerOwen s ; unsigned int param_nbsamples = 1024 ; s . generateSamples < 2 , double , Point < 2 , double > > ( pts , param_nbsamples ); writer . writePointset ( pts ); writer . close ();","title":"Execution"},{"location":"sampler_owen/#results","text":"./bin/samplers/Owen_2dd -o owen_1024.edat -n 1024 File owen_1024.edat Pointset Fourier ./bin/samplers/Owen_2dd -o owen_4096.edat -n 4096 File owen_4096.edat Pointset Fourier","title":"Results"},{"location":"sampler_penrose/","text":"Sampler Penrose [ODJ04] Files src/samplers/SamplerPenrose.hpp src/bin/samplers/Penrose_2dd.cpp Description The Penrose sampler from [ODJ04] . For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html . License File: quasisampler_prototype.h Quasisampler prototype. This is a toy (non-optimized) implementation of the importance sampling technique proposed in the paper: \"Fast Hierarchical Importance Sampling with Blue Noise Properties\", by Victor Ostromoukhov, Charles Donohue and Pierre-Marc Jodoin, to be presented at SIGGRAPH 2004. Implementation by Charles Donohue, Based on Mathematica code by Victor Ostromoukhov. Universite de Montreal 18.08.04 Execution Parameters: [HELP] -o [string = output_pts.dat] Output file -m [int = 1] Number of poinset realisations -n [ullint = 1024] Number of samples to generate --silent Silent mode -h Displays this help message To generate a 2D point set of 1024 samples with a penrose distribution, we can use the following client line command: ./bin/samplers/Penrose_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter< 2, double, Point<2, double> > writer; writer.open(\"toto.dat\"); Pointset< 2, double, Point<2, double> > pts; SamplerPenrose s; unsigned int param_nbsamples = 1024; s.generateSamples< 2, double, Point<2, double> >(pts, param_nbsamples); writer.writePointset(pts); writer.close(); Results ./bin/samplers/Penrose_2dd -o penrose_1024.edat -n 1024 File penrose_1024.edat Pointset Fourier ./bin/samplers/Penrose_2dd -o penrose_4096.edat -n 4096 File penrose_4096.edat Pointset Fourier","title":"Penrose"},{"location":"sampler_penrose/#sampler-penrose-odj04","text":"","title":"Sampler Penrose [ODJ04]"},{"location":"sampler_penrose/#files","text":"src/samplers/SamplerPenrose.hpp src/bin/samplers/Penrose_2dd.cpp","title":"Files"},{"location":"sampler_penrose/#description","text":"The Penrose sampler from [ODJ04] . For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html .","title":"Description"},{"location":"sampler_penrose/#license","text":"File: quasisampler_prototype.h Quasisampler prototype. This is a toy (non-optimized) implementation of the importance sampling technique proposed in the paper: \"Fast Hierarchical Importance Sampling with Blue Noise Properties\", by Victor Ostromoukhov, Charles Donohue and Pierre-Marc Jodoin, to be presented at SIGGRAPH 2004. Implementation by Charles Donohue, Based on Mathematica code by Victor Ostromoukhov. Universite de Montreal 18.08.04","title":"License"},{"location":"sampler_penrose/#execution","text":"Parameters: [HELP] -o [string = output_pts.dat] Output file -m [int = 1] Number of poinset realisations -n [ullint = 1024] Number of samples to generate --silent Silent mode -h Displays this help message To generate a 2D point set of 1024 samples with a penrose distribution, we can use the following client line command: ./bin/samplers/Penrose_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter< 2, double, Point<2, double> > writer; writer.open(\"toto.dat\"); Pointset< 2, double, Point<2, double> > pts; SamplerPenrose s; unsigned int param_nbsamples = 1024; s.generateSamples< 2, double, Point<2, double> >(pts, param_nbsamples); writer.writePointset(pts); writer.close();","title":"Execution"},{"location":"sampler_penrose/#results","text":"./bin/samplers/Penrose_2dd -o penrose_1024.edat -n 1024 File penrose_1024.edat Pointset Fourier ./bin/samplers/Penrose_2dd -o penrose_4096.edat -n 4096 File penrose_4096.edat Pointset Fourier","title":"Results"},{"location":"sampler_rank1/","text":"Sampler Rank 1 [DK08] Files src/samplers/SamplerRank1.hpp src/bin/samplers/Rank1_2dd.cpp.cpp Description The Rank 1 lattices from [Keller04] . For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html . License Execution Parameters: [HELP] -o [string=output_pts.dat] Output file -m [int=1] Number of poinset realisations -n [ullint=1024] Number of samples to generate --silent Silent mode -h Displays this help message --fibonacci Uses the fibonnacci sequence as indices To generate a 2D point set of 1024 samples with a rank1 distribution, we can use the following client line command: ./bin/samplers/Rank1_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter < 2 , double , Point < 2 , double > > writer ; writer . open ( \"toto.dat\" ); Pointset < 2 , double , Point < 2 , double > > pts ; SamplerRank1 s ; unsigned int param_nbsamples = 1024 ; s . generateSamples < 2 , double , Point < 2 , double > > ( pts , param_nbsamples ); writer . writePointset ( pts ); writer . close (); Results ./bin/samplers/Rank1_2dd -o rank1_1024.edat -n 1024 File rank1_1024.edat Pointset Fourier ./bin/samplers/Rank1_2dd -o rank1_4096.edat -n 4096 File rank1_4096.edat Pointset Fourier ./bin/samplers/Rank1_2dd --fibonacci -o rank1_fib_1024.edat -n 1024 File rank1_fib_1024.edat Pointset Fourier ./bin/samplers/Rank1_2dd --fibonacci -o rank1_fib_4096.edat -n 4096 File rank1_fib_4096.edat Pointset Fourier","title":"Rank 1"},{"location":"sampler_rank1/#sampler-rank-1-dk08","text":"","title":"Sampler Rank 1 [DK08]"},{"location":"sampler_rank1/#files","text":"src/samplers/SamplerRank1.hpp src/bin/samplers/Rank1_2dd.cpp.cpp","title":"Files"},{"location":"sampler_rank1/#description","text":"The Rank 1 lattices from [Keller04] . For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html .","title":"Description"},{"location":"sampler_rank1/#license","text":"","title":"License"},{"location":"sampler_rank1/#execution","text":"Parameters: [HELP] -o [string=output_pts.dat] Output file -m [int=1] Number of poinset realisations -n [ullint=1024] Number of samples to generate --silent Silent mode -h Displays this help message --fibonacci Uses the fibonnacci sequence as indices To generate a 2D point set of 1024 samples with a rank1 distribution, we can use the following client line command: ./bin/samplers/Rank1_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter < 2 , double , Point < 2 , double > > writer ; writer . open ( \"toto.dat\" ); Pointset < 2 , double , Point < 2 , double > > pts ; SamplerRank1 s ; unsigned int param_nbsamples = 1024 ; s . generateSamples < 2 , double , Point < 2 , double > > ( pts , param_nbsamples ); writer . writePointset ( pts ); writer . close ();","title":"Execution"},{"location":"sampler_rank1/#results","text":"./bin/samplers/Rank1_2dd -o rank1_1024.edat -n 1024 File rank1_1024.edat Pointset Fourier ./bin/samplers/Rank1_2dd -o rank1_4096.edat -n 4096 File rank1_4096.edat Pointset Fourier ./bin/samplers/Rank1_2dd --fibonacci -o rank1_fib_1024.edat -n 1024 File rank1_fib_1024.edat Pointset Fourier ./bin/samplers/Rank1_2dd --fibonacci -o rank1_fib_4096.edat -n 4096 File rank1_fib_4096.edat Pointset Fourier","title":"Results"},{"location":"sampler_regular_grid/","text":"Sampler Regular Grid Files src/samplers/SamplerRegularGrid.hpp src/bin/samplers/RegularGrid_*dd.cpp Description A regular grid. For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html . Execution Parameters: [HELP] -o [string = output_pts.dat] Output file -m [int = 1] Number of poinset realisations -n [ullint = 1024] Number of samples to generate --silent Silent mode -h Displays this help message To generate a 2D point set of 1024 samples with a regular_grid distribution, we can use the following client line command: ./bin/samplers/RegularGrid_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter< 2, double, Point<2, double> > writer; writer.open(\"toto.dat\"); Pointset< 2, double, Point<2, double> > pts; SamplerRegularGrid s; unsigned int param_nbsamples = 1024; s.generateSamples< 2, double, Point<2, double> >(pts, param_nbsamples); writer.writePointset(pts); writer.close(); Results ./bin/samplers/RegularGrid_2dd -o regular_grid_1024.edat -n 1024 File regular_grid_1024.edat Pointset Fourier ./bin/samplers/RegularGrid_2dd -o regular_grid_4096.edat -n 4096 File regular_grid_4096.edat Pointset Fourier","title":"Regular grid"},{"location":"sampler_regular_grid/#sampler-regular-grid","text":"","title":"Sampler Regular Grid"},{"location":"sampler_regular_grid/#files","text":"src/samplers/SamplerRegularGrid.hpp src/bin/samplers/RegularGrid_*dd.cpp","title":"Files"},{"location":"sampler_regular_grid/#description","text":"A regular grid. For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html .","title":"Description"},{"location":"sampler_regular_grid/#execution","text":"Parameters: [HELP] -o [string = output_pts.dat] Output file -m [int = 1] Number of poinset realisations -n [ullint = 1024] Number of samples to generate --silent Silent mode -h Displays this help message To generate a 2D point set of 1024 samples with a regular_grid distribution, we can use the following client line command: ./bin/samplers/RegularGrid_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter< 2, double, Point<2, double> > writer; writer.open(\"toto.dat\"); Pointset< 2, double, Point<2, double> > pts; SamplerRegularGrid s; unsigned int param_nbsamples = 1024; s.generateSamples< 2, double, Point<2, double> >(pts, param_nbsamples); writer.writePointset(pts); writer.close();","title":"Execution"},{"location":"sampler_regular_grid/#results","text":"./bin/samplers/RegularGrid_2dd -o regular_grid_1024.edat -n 1024 File regular_grid_1024.edat Pointset Fourier ./bin/samplers/RegularGrid_2dd -o regular_grid_4096.edat -n 4096 File regular_grid_4096.edat Pointset Fourier","title":"Results"},{"location":"sampler_singlepeak/","text":"Sampler Single Peak [HSD13] Files src/samplers/SamplerSinglePeak.hpp src/bin/samplers/SinglePeak_2dd.cpp.cpp Description The sampler from [HSD13] with a single peak profile. For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html . License // // Source code for the paper, edited to fit the utk framework // // D. Heck and T. Schloemer and O. Deussen, \"Blue Noise Sampling with // Controlled Aliasing\", ACM Trans. Graph., 2013, in press // // Copyright (C) 2012,2013 Daniel Heck and Thomas Schloemer // ``` ## Execution Parameters: [HELP] -o [string = output_pts.dat] Output file -m [int = 1] Number of poinset realisations -n [ullint = 1024] Number of samples to generate --silent Silent mode -h Displays this help message To generate a 2D point set of 1024 samples with a singlepeak distribution, we can use the following client line command: ./bin/samplers/SinglePeak_2dd -n 1024 -o toto.dat Or one can use the following C++ code: cpp PointsetWriter< 2, double, Point<2, double> > writer; writer.open(\u201ctoto.dat\u201d); Pointset< 2, double, Point<2, double> > pts; SamplerSinglePeak s; unsigned int param_nbsamples = 1024; s.generateSamples< 2, double, Point<2, double> >(pts, param_nbsamples); writer.writePointset(pts); writer.close(); ``` Results ./bin/samplers/SinglePeak_2dd -o singlepeak_1024.edat -n 1024 File singlepeak_1024.edat Pointset Fourier ./bin/samplers/SinglePeak_2dd -o singlepeak_4096.edat -n 4096 File singlepeak_4096.edat Pointset Fourier","title":"Single Peak"},{"location":"sampler_singlepeak/#sampler-single-peak-hsd13","text":"","title":"Sampler Single Peak [HSD13]"},{"location":"sampler_singlepeak/#files","text":"src/samplers/SamplerSinglePeak.hpp src/bin/samplers/SinglePeak_2dd.cpp.cpp","title":"Files"},{"location":"sampler_singlepeak/#description","text":"The sampler from [HSD13] with a single peak profile. For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html .","title":"Description"},{"location":"sampler_singlepeak/#license","text":"// // Source code for the paper, edited to fit the utk framework // // D. Heck and T. Schloemer and O. Deussen, \"Blue Noise Sampling with // Controlled Aliasing\", ACM Trans. Graph., 2013, in press // // Copyright (C) 2012,2013 Daniel Heck and Thomas Schloemer // ``` ## Execution Parameters: [HELP] -o [string = output_pts.dat] Output file -m [int = 1] Number of poinset realisations -n [ullint = 1024] Number of samples to generate --silent Silent mode -h Displays this help message To generate a 2D point set of 1024 samples with a singlepeak distribution, we can use the following client line command: ./bin/samplers/SinglePeak_2dd -n 1024 -o toto.dat Or one can use the following C++ code: cpp PointsetWriter< 2, double, Point<2, double> > writer; writer.open(\u201ctoto.dat\u201d); Pointset< 2, double, Point<2, double> > pts; SamplerSinglePeak s; unsigned int param_nbsamples = 1024; s.generateSamples< 2, double, Point<2, double> >(pts, param_nbsamples); writer.writePointset(pts); writer.close(); ```","title":"License"},{"location":"sampler_singlepeak/#results","text":"./bin/samplers/SinglePeak_2dd -o singlepeak_1024.edat -n 1024 File singlepeak_1024.edat Pointset Fourier ./bin/samplers/SinglePeak_2dd -o singlepeak_4096.edat -n 4096 File singlepeak_4096.edat Pointset Fourier","title":"Results"},{"location":"sampler_sobolindiced/","text":"Sampler Sobol Indiced [Sob67] Files src/samplers/SamplerSobolIndices.hpp src/bin/samplers/SobolIndices_*d*.cpp.cpp Description The Sobol sequence. Samples are generated from a binary product between the binary representation of their index and a matrix, generated from primitive polynomials. The primitive polynomials are indiced based on OEIS For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html . Execution Parameters: [HELP] -o [string=output_pts.dat] Output file -m [int=1] Number of poinset realisations -n [ullint=1024] Number of samples to generate --silent Silent mode -h Displays this help message -x [uint=1] Sobol Index on X dimension -y [uint=2] Sobol Index on Y dimension To generate a 2D point set of 1024 samples with a sobolindiced distribution, we can use the following client line command: ./bin/samplers/SobolIndices_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter < 2 , double , Point < 2 , double > > writer ; writer . open ( \"toto.dat\" ); Pointset < 2 , double , Point < 2 , double > > pts ; SamplerSobolIndices s ; unsigned int param_nbsamples = 1024 ; int sobolIdX = 1 ; int sobolIdY = 2 ; int indices [ 2 ] = { sobolIdX , sobolIdY }; s . setIndices ( indices , 2 ); s . generateSamples < 2 , double , Point < 2 , double > > ( pts , param_nbsamples ); writer . writePointset ( pts ); writer . close (); Results ./bin/samplers/SobolIndices_2dd -o sobolindiced_1024.edat -n 1024 File sobolindiced_1024.edat Pointset Fourier ./bin/samplers/SobolIndices_2dd -o sobolindiced_4096.edat -n 4096 File sobolindiced_4096.edat Pointset Fourier ./bin/samplers/SobolIndices_2dd -x 3 -y 4 -o sobolindiced_34_1024.edat -n 1024 File sobolindiced_34_1024.edat Pointset Fourier ./bin/samplers/SobolIndices_2dd -x 5 -y 6 -o sobolindiced_56_1024.edat -n 1024 File sobolindiced_56_1024.edat Pointset Fourier","title":"Sobol (Original)"},{"location":"sampler_sobolindiced/#sampler-sobol-indiced-sob67","text":"","title":"Sampler Sobol Indiced [Sob67]"},{"location":"sampler_sobolindiced/#files","text":"src/samplers/SamplerSobolIndices.hpp src/bin/samplers/SobolIndices_*d*.cpp.cpp","title":"Files"},{"location":"sampler_sobolindiced/#description","text":"The Sobol sequence. Samples are generated from a binary product between the binary representation of their index and a matrix, generated from primitive polynomials. The primitive polynomials are indiced based on OEIS For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html .","title":"Description"},{"location":"sampler_sobolindiced/#execution","text":"Parameters: [HELP] -o [string=output_pts.dat] Output file -m [int=1] Number of poinset realisations -n [ullint=1024] Number of samples to generate --silent Silent mode -h Displays this help message -x [uint=1] Sobol Index on X dimension -y [uint=2] Sobol Index on Y dimension To generate a 2D point set of 1024 samples with a sobolindiced distribution, we can use the following client line command: ./bin/samplers/SobolIndices_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter < 2 , double , Point < 2 , double > > writer ; writer . open ( \"toto.dat\" ); Pointset < 2 , double , Point < 2 , double > > pts ; SamplerSobolIndices s ; unsigned int param_nbsamples = 1024 ; int sobolIdX = 1 ; int sobolIdY = 2 ; int indices [ 2 ] = { sobolIdX , sobolIdY }; s . setIndices ( indices , 2 ); s . generateSamples < 2 , double , Point < 2 , double > > ( pts , param_nbsamples ); writer . writePointset ( pts ); writer . close ();","title":"Execution"},{"location":"sampler_sobolindiced/#results","text":"./bin/samplers/SobolIndices_2dd -o sobolindiced_1024.edat -n 1024 File sobolindiced_1024.edat Pointset Fourier ./bin/samplers/SobolIndices_2dd -o sobolindiced_4096.edat -n 4096 File sobolindiced_4096.edat Pointset Fourier ./bin/samplers/SobolIndices_2dd -x 3 -y 4 -o sobolindiced_34_1024.edat -n 1024 File sobolindiced_34_1024.edat Pointset Fourier ./bin/samplers/SobolIndices_2dd -x 5 -y 6 -o sobolindiced_56_1024.edat -n 1024 File sobolindiced_56_1024.edat Pointset Fourier","title":"Results"},{"location":"sampler_sobolkuo/","text":"Sampler Sobol [JK03] Files src/samplers/SamplerSobol.hpp src/bin/samplers/Sobol_*dd.cpp.cpp Description The Sobol sequence. Samples are generated from a binary product between the binary representation of their index and a matrix, generated from primitive polynomials. The code from this sampler is from [JK03] . For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html . License BSD-like, see https://web.maths.unsw.edu.au/~fkuo/sobol/ . Execution Parameters: [HELP] -o [string=output_pts.dat] Output file -m [int=1] Number of poinset realisations -n [ullint=1024] Number of samples to generate --silent Silent mode -h Displays this help message -d \u2039string\u203a File containing the direction numbers To generate a 2D point set of 1024 samples with a sobolkuo distribution, we can use the following client line command: ./bin/samplers/Sobol_2dd -d ../../data/sobol/new-joe-kuo-6.21201 -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter < 2 , double , Point < 2 , double > > writer ; writer . open ( \"toto.dat\" ); Pointset < 2 , double , Point < 2 , double > > pts ; SamplerSobol s ; unsigned int param_nbsamples = 1024 ; s . generateSamples < 2 , double , Point < 2 , double > > ( pts , param_nbsamples ); writer . writePointset ( pts ); writer . close (); Results ./bin/samplers/Sobol_2dd -d ../../data/sobol/new-joe-kuo-6.21201 -o sobolkuo_1024.edat -n 1024 File sobolkuo_1024.edat Pointset Fourier ./bin/samplers/Sobol_2dd -d ../../data/sobol/new-joe-kuo-6.21201 -o sobolkuo_4096.edat -n 4096 File sobolkuo_4096.edat Pointset Fourier","title":"Sobol (Joe&Kuo)"},{"location":"sampler_sobolkuo/#sampler-sobol-jk03","text":"","title":"Sampler Sobol [JK03]"},{"location":"sampler_sobolkuo/#files","text":"src/samplers/SamplerSobol.hpp src/bin/samplers/Sobol_*dd.cpp.cpp","title":"Files"},{"location":"sampler_sobolkuo/#description","text":"The Sobol sequence. Samples are generated from a binary product between the binary representation of their index and a matrix, generated from primitive polynomials. The code from this sampler is from [JK03] . For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html .","title":"Description"},{"location":"sampler_sobolkuo/#license","text":"BSD-like, see https://web.maths.unsw.edu.au/~fkuo/sobol/ .","title":"License"},{"location":"sampler_sobolkuo/#execution","text":"Parameters: [HELP] -o [string=output_pts.dat] Output file -m [int=1] Number of poinset realisations -n [ullint=1024] Number of samples to generate --silent Silent mode -h Displays this help message -d \u2039string\u203a File containing the direction numbers To generate a 2D point set of 1024 samples with a sobolkuo distribution, we can use the following client line command: ./bin/samplers/Sobol_2dd -d ../../data/sobol/new-joe-kuo-6.21201 -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter < 2 , double , Point < 2 , double > > writer ; writer . open ( \"toto.dat\" ); Pointset < 2 , double , Point < 2 , double > > pts ; SamplerSobol s ; unsigned int param_nbsamples = 1024 ; s . generateSamples < 2 , double , Point < 2 , double > > ( pts , param_nbsamples ); writer . writePointset ( pts ); writer . close ();","title":"Execution"},{"location":"sampler_sobolkuo/#results","text":"./bin/samplers/Sobol_2dd -d ../../data/sobol/new-joe-kuo-6.21201 -o sobolkuo_1024.edat -n 1024 File sobolkuo_1024.edat Pointset Fourier ./bin/samplers/Sobol_2dd -d ../../data/sobol/new-joe-kuo-6.21201 -o sobolkuo_4096.edat -n 4096 File sobolkuo_4096.edat Pointset Fourier","title":"Results"},{"location":"sampler_step/","text":"Sampler Step [HSD13] Files src/samplers/SamplerStep.hpp src/bin/samplers/Step_2dd.cpp Description The sampler from [HSD13] with a step profile. For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html . License // // Source code for the paper, edited to fit the utk framework // // D. Heck and T. Schloemer and O. Deussen, \"Blue Noise Sampling with // Controlled Aliasing\", ACM Trans. Graph., 2013, in press // // Copyright (C) 2012,2013 Daniel Heck and Thomas Schloemer // Execution Parameters: [HELP] -o [string = output_pts.dat] Output file -m [int = 1] Number of poinset realisations -n [ullint = 1024] Number of samples to generate --silent Silent mode -h Displays this help message To generate a 2D point set of 1024 samples with a step distribution, we can use the following client line command: ./bin/samplers/Step_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter< 2, double, Point<2, double> > writer; writer.open(\"toto.dat\"); Pointset< 2, double, Point<2, double> > pts; SamplerStep s; unsigned int param_nbsamples = 1024; s.generateSamples< 2, double, Point<2, double> >(pts, param_nbsamples); writer.writePointset(pts); writer.close(); Results ./bin/samplers/Step_2dd -o step_1024.edat -n 1024 File step_1024.edat Pointset Fourier ./bin/samplers/Step_2dd -o step_4096.edat -n 4096 File step_4096.edat Pointset Fourier","title":"Step"},{"location":"sampler_step/#sampler-step-hsd13","text":"","title":"Sampler Step [HSD13]"},{"location":"sampler_step/#files","text":"src/samplers/SamplerStep.hpp src/bin/samplers/Step_2dd.cpp","title":"Files"},{"location":"sampler_step/#description","text":"The sampler from [HSD13] with a step profile. For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html .","title":"Description"},{"location":"sampler_step/#license","text":"// // Source code for the paper, edited to fit the utk framework // // D. Heck and T. Schloemer and O. Deussen, \"Blue Noise Sampling with // Controlled Aliasing\", ACM Trans. Graph., 2013, in press // // Copyright (C) 2012,2013 Daniel Heck and Thomas Schloemer //","title":"License"},{"location":"sampler_step/#execution","text":"Parameters: [HELP] -o [string = output_pts.dat] Output file -m [int = 1] Number of poinset realisations -n [ullint = 1024] Number of samples to generate --silent Silent mode -h Displays this help message To generate a 2D point set of 1024 samples with a step distribution, we can use the following client line command: ./bin/samplers/Step_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter< 2, double, Point<2, double> > writer; writer.open(\"toto.dat\"); Pointset< 2, double, Point<2, double> > pts; SamplerStep s; unsigned int param_nbsamples = 1024; s.generateSamples< 2, double, Point<2, double> >(pts, param_nbsamples); writer.writePointset(pts); writer.close();","title":"Execution"},{"location":"sampler_step/#results","text":"./bin/samplers/Step_2dd -o step_1024.edat -n 1024 File step_1024.edat Pointset Fourier ./bin/samplers/Step_2dd -o step_4096.edat -n 4096 File step_4096.edat Pointset Fourier","title":"Results"},{"location":"sampler_stratified/","text":"Sampler stratified Files src/samplers/SamplerStratified.hpp src/bin/samplers/Stratified_*.cpp Description The domain is partitioned with a grid of k x k. In each cell of this grid, a random sample is generated. For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html . Execution Parameters: [HELP] -o [string = output_pts.dat] Output file -m [int = 1] Number of poinset realisations -n [ullint = 1024] Number of samples to generate --silent Silent mode -h Displays this help message To generate a 2D point set of 1024 samples with a stratified distribution, we can use the following client line command: ./bin/samplers/Stratified_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter< 2, double, Point<2, double> > writer; writer.open(\"toto.dat\"); Pointset< 2, double, Point<2, double> > pts; SamplerStratified s; unsigned int param_nbsamples = 1024; s.generateSamples< 2, double, Point<2, double> >(pts, param_nbsamples); writer.writePointset(pts); writer.close(); Results ./bin/samplers/Stratified_2dd -o stratified_1024.edat -n 1024 File stratified_1024.edat Pointset Fourier ./bin/samplers/Stratified_2dd -o stratified_4096.edat -n 4096 File stratified_4096.edat Pointset Fourier","title":"Stratified"},{"location":"sampler_stratified/#sampler-stratified","text":"","title":"Sampler stratified"},{"location":"sampler_stratified/#files","text":"src/samplers/SamplerStratified.hpp src/bin/samplers/Stratified_*.cpp","title":"Files"},{"location":"sampler_stratified/#description","text":"The domain is partitioned with a grid of k x k. In each cell of this grid, a random sample is generated. For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html .","title":"Description"},{"location":"sampler_stratified/#execution","text":"Parameters: [HELP] -o [string = output_pts.dat] Output file -m [int = 1] Number of poinset realisations -n [ullint = 1024] Number of samples to generate --silent Silent mode -h Displays this help message To generate a 2D point set of 1024 samples with a stratified distribution, we can use the following client line command: ./bin/samplers/Stratified_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter< 2, double, Point<2, double> > writer; writer.open(\"toto.dat\"); Pointset< 2, double, Point<2, double> > pts; SamplerStratified s; unsigned int param_nbsamples = 1024; s.generateSamples< 2, double, Point<2, double> >(pts, param_nbsamples); writer.writePointset(pts); writer.close();","title":"Execution"},{"location":"sampler_stratified/#results","text":"./bin/samplers/Stratified_2dd -o stratified_1024.edat -n 1024 File stratified_1024.edat Pointset Fourier ./bin/samplers/Stratified_2dd -o stratified_4096.edat -n 4096 File stratified_4096.edat Pointset Fourier","title":"Results"},{"location":"sampler_whitenoise/","text":"Sampler whitenoise Files src/samplers/SamplerWhitenoise.hpp src/bin/samplers/Whitenoise_*.cpp Description A pure random sampler For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html . Execution Parameters: [HELP] -o [string = output_pts.dat] Output file -m [int = 1] Number of poinset realisations -n [ullint = 1024] Number of samples to generate --silent Silent mode -h Displays this help message To generate a 2D point set of 1024 samples with a whitenoise distribution, we can use the following client line command: ./bin/samplers/Whitenoise_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter< 2, double, Point<2, double> > writer; writer.open(\"toto.dat\"); Pointset< 2, double, Point<2, double> > pts; SamplerWhitenoise s; unsigned int param_nbsamples = 1024; s.generateSamples< 2, double, Point<2, double> >(pts, param_nbsamples); writer.writePointset(pts); writer.close(); Results ./bin/samplers/Whitenoise_2dd -o whitenoise_1024.edat -n 1024 File whitenoise_1024.edat Pointset Fourier ./bin/samplers/Whitenoise_2dd -o whitenoise_4096.edat -n 4096 File whitenoise_4096.edat Pointset Fourier","title":"Whitenoise"},{"location":"sampler_whitenoise/#sampler-whitenoise","text":"","title":"Sampler whitenoise"},{"location":"sampler_whitenoise/#files","text":"src/samplers/SamplerWhitenoise.hpp src/bin/samplers/Whitenoise_*.cpp","title":"Files"},{"location":"sampler_whitenoise/#description","text":"A pure random sampler For a more precise description of this sampler and its performances in terms of aliasing and discrepancy, please refer to the following web bundle https://liris.cnrs.fr/ldbn/HTML_bundle/index.html .","title":"Description"},{"location":"sampler_whitenoise/#execution","text":"Parameters: [HELP] -o [string = output_pts.dat] Output file -m [int = 1] Number of poinset realisations -n [ullint = 1024] Number of samples to generate --silent Silent mode -h Displays this help message To generate a 2D point set of 1024 samples with a whitenoise distribution, we can use the following client line command: ./bin/samplers/Whitenoise_2dd -n 1024 -o toto.dat Or one can use the following C++ code: PointsetWriter< 2, double, Point<2, double> > writer; writer.open(\"toto.dat\"); Pointset< 2, double, Point<2, double> > pts; SamplerWhitenoise s; unsigned int param_nbsamples = 1024; s.generateSamples< 2, double, Point<2, double> >(pts, param_nbsamples); writer.writePointset(pts); writer.close();","title":"Execution"},{"location":"sampler_whitenoise/#results","text":"./bin/samplers/Whitenoise_2dd -o whitenoise_1024.edat -n 1024 File whitenoise_1024.edat Pointset Fourier ./bin/samplers/Whitenoise_2dd -o whitenoise_4096.edat -n 4096 File whitenoise_4096.edat Pointset Fourier","title":"Results"},{"location":"samplers/","text":"Samplers All samplers are illustrated in 2D but most of them are available in higher dimensions. Please have a look to the code for more details. Low Discrepancy Samplers Sampler License Illustration Faure LGPL Halton BSD Hammersley BSD Niederreiter LGPL Sobol (code from [JK03] ) BSD Sobol (Original) BSD Owen (Sobol) BSD Rank 1 ?? LDBN BSD BNLD Sequences BSD Progressive MultiJittered Sampling BSD Blue Noise Samplers Sampler License Illustration AA Patterns See doc ART See doc CVT See doc CapCVT See doc Forced Random open FPO See doc LDBN BSD Penrose See doc BNOT BSD and GPL Lloyd 3D See doc Poisson Disk Samplers Sampler License Illustration Dart Throwing BSD Fast Poisson Disk Public domain Other Samplers Sampler License Illustration CMJ BSD Hexagonal Grid BSD Korobov BSD NRooks BSD Regular Grid BSD Single Peak See doc Step See doc Stratified BSD Whitenoise BSD Experimental Samplers Sampler License Illustration Exhaustive Owen BSD Genetic Owen BSD Gradient descent BSD","title":"---All samplers---"},{"location":"samplers/#samplers","text":"All samplers are illustrated in 2D but most of them are available in higher dimensions. Please have a look to the code for more details.","title":"Samplers"},{"location":"samplers/#low-discrepancy-samplers","text":"Sampler License Illustration Faure LGPL Halton BSD Hammersley BSD Niederreiter LGPL Sobol (code from [JK03] ) BSD Sobol (Original) BSD Owen (Sobol) BSD Rank 1 ?? LDBN BSD BNLD Sequences BSD Progressive MultiJittered Sampling BSD","title":"Low Discrepancy Samplers"},{"location":"samplers/#blue-noise-samplers","text":"Sampler License Illustration AA Patterns See doc ART See doc CVT See doc CapCVT See doc Forced Random open FPO See doc LDBN BSD Penrose See doc BNOT BSD and GPL Lloyd 3D See doc","title":"Blue Noise Samplers"},{"location":"samplers/#poisson-disk-samplers","text":"Sampler License Illustration Dart Throwing BSD Fast Poisson Disk Public domain","title":"Poisson Disk Samplers"},{"location":"samplers/#other-samplers","text":"Sampler License Illustration CMJ BSD Hexagonal Grid BSD Korobov BSD NRooks BSD Regular Grid BSD Single Peak See doc Step See doc Stratified BSD Whitenoise BSD","title":"Other Samplers"},{"location":"samplers/#experimental-samplers","text":"Sampler License Illustration Exhaustive Owen BSD Genetic Owen BSD Gradient descent BSD","title":"Experimental Samplers"},{"location":"scrambling_cranleypatterson/","text":"Scrambling Cranley Patterson Files src/scrambling/ScramblingCranleyPatterson.hpp src/scrambling/CranleyPatterson_*d*.cpp Description Randomize a point set. Picks D random values which are each added to the D^th coordinate of each sample of the input point set. If the point gets outside the domain, it is torically duplicated. Execution Parameters: [HELP] -i [string] Input file -o [string=output_pts.dat] Output file --silent Silent mode -h Displays this help message To generate a 2D point set of 1024 samples with a whitenoise distribution, we can use the following client line command: ./src/scrambling/CranleyPatterson_2dd -i pointset.edat -o scrambledset.edat Or one can use the following C++ code: ScramblingCranleyPatterson scrambler; Pointset< D, T, P > pts; Pointset< D, T, P > pts_scrambled; //we assume pts is filled scrambler.scramble< D, T, P >(pts, pts_scrambled); PointsetWriter< D, T, P > writer; writer.open(\"scrambledset.edat\"); writer.writePointset(pts_scrambled); writer.close(); Results ./src/scrambling/CranleyPatterson_2di -i sobol_m3_1024.edat -o scrambled.edat Input sobol_m3_1024.edat Output scrambled_m3.edat","title":"Cranley Patterson"},{"location":"scrambling_cranleypatterson/#scrambling-cranley-patterson","text":"","title":"Scrambling Cranley Patterson"},{"location":"scrambling_cranleypatterson/#files","text":"src/scrambling/ScramblingCranleyPatterson.hpp src/scrambling/CranleyPatterson_*d*.cpp","title":"Files"},{"location":"scrambling_cranleypatterson/#description","text":"Randomize a point set. Picks D random values which are each added to the D^th coordinate of each sample of the input point set. If the point gets outside the domain, it is torically duplicated.","title":"Description"},{"location":"scrambling_cranleypatterson/#execution","text":"Parameters: [HELP] -i [string] Input file -o [string=output_pts.dat] Output file --silent Silent mode -h Displays this help message To generate a 2D point set of 1024 samples with a whitenoise distribution, we can use the following client line command: ./src/scrambling/CranleyPatterson_2dd -i pointset.edat -o scrambledset.edat Or one can use the following C++ code: ScramblingCranleyPatterson scrambler; Pointset< D, T, P > pts; Pointset< D, T, P > pts_scrambled; //we assume pts is filled scrambler.scramble< D, T, P >(pts, pts_scrambled); PointsetWriter< D, T, P > writer; writer.open(\"scrambledset.edat\"); writer.writePointset(pts_scrambled); writer.close();","title":"Execution"},{"location":"scrambling_cranleypatterson/#results","text":"./src/scrambling/CranleyPatterson_2di -i sobol_m3_1024.edat -o scrambled.edat Input sobol_m3_1024.edat Output scrambled_m3.edat","title":"Results"},{"location":"scrambling_digitalxor/","text":"Scrambling Digital XOR Files src/scrambling/ScramblingDigitalXOR.hpp src/scrambling/DigitalXOR_*di.cpp Description Randomize a point set with integer coordinates. Picks D random values which are each xored to the D^th coordinate of each sample of the input point set. Execution Parameters: [HELP] -i [string] Input file -o [string=output_pts.dat] Output file --silent Silent mode -h Displays this help message To generate a 2D point set of 1024 samples with a whitenoise distribution, we can use the following client line command: ./src/scrambling/CranleyPatterson_2dd -i pointset.edat -o scrambledset.edat Or one can use the following C++ code: ScramblingDigitalXOR scrambler ; Pointset < D , T , P > pts ; Pointset < D , T , P > pts_scrambled ; //we assume pts is filled scrambler . scramble < D , T , P > ( pts , pts_scrambled ); PointsetWriter < D , T , P > writer ; writer . open ( \"scrambledset.edat\" ); writer . writePointset ( pts_scrambled ); writer . close (); Results ./src/scrambling/DigitalXOR_2di -i sobol_m3_1024.edat -o scrambled.edat Input sobol_m3_1024.edat Output scrambled_m3.edat","title":"Digital XOR"},{"location":"scrambling_digitalxor/#scrambling-digital-xor","text":"","title":"Scrambling Digital XOR"},{"location":"scrambling_digitalxor/#files","text":"src/scrambling/ScramblingDigitalXOR.hpp src/scrambling/DigitalXOR_*di.cpp","title":"Files"},{"location":"scrambling_digitalxor/#description","text":"Randomize a point set with integer coordinates. Picks D random values which are each xored to the D^th coordinate of each sample of the input point set.","title":"Description"},{"location":"scrambling_digitalxor/#execution","text":"Parameters: [HELP] -i [string] Input file -o [string=output_pts.dat] Output file --silent Silent mode -h Displays this help message To generate a 2D point set of 1024 samples with a whitenoise distribution, we can use the following client line command: ./src/scrambling/CranleyPatterson_2dd -i pointset.edat -o scrambledset.edat Or one can use the following C++ code: ScramblingDigitalXOR scrambler ; Pointset < D , T , P > pts ; Pointset < D , T , P > pts_scrambled ; //we assume pts is filled scrambler . scramble < D , T , P > ( pts , pts_scrambled ); PointsetWriter < D , T , P > writer ; writer . open ( \"scrambledset.edat\" ); writer . writePointset ( pts_scrambled ); writer . close ();","title":"Execution"},{"location":"scrambling_digitalxor/#results","text":"./src/scrambling/DigitalXOR_2di -i sobol_m3_1024.edat -o scrambled.edat Input sobol_m3_1024.edat Output scrambled_m3.edat","title":"Results"},{"location":"scrambling_owen/","text":"Scrambling Owen Files src/scrambling/ScramblingOwen.hpp src/scrambling/OwenScrambling_*di.cpp Description Randomize a point set with integer coordinates using Owen\u2019s scrambling. License BSD, see ScramblingOwen.hpp Execution Parameters: [HELP] -i [string] Input file -o [string=output_pts.dat] Output file --silent Silent mode -h Displays this help message To generate a 2D point set of 1024 samples with a whitenoise distribution, we can use the following client line command: ./src/scrambling/CranleyPatterson_2dd -i pointset.edat -o scrambledset.edat Or one can use the following C++ code: ScramblingOwen scrambler ; Pointset < D , T , P > pts ; Pointset < D , T , P > pts_scrambled ; //we assume pts is filled scrambler . scramble < D , T , P > ( pts , pts_scrambled ); PointsetWriter < D , T , P > writer ; writer . open ( \"scrambledset.edat\" ); writer . writePointset ( pts_scrambled ); writer . close (); Results ./src/scrambling/DigitalXOR_2di -i sobol_m3_1024.edat -o scrambled.edat Input sobol_m3_1024.edat Output scrambled_m3.edat","title":"Owen Scrambling"},{"location":"scrambling_owen/#scrambling-owen","text":"","title":"Scrambling Owen"},{"location":"scrambling_owen/#files","text":"src/scrambling/ScramblingOwen.hpp src/scrambling/OwenScrambling_*di.cpp","title":"Files"},{"location":"scrambling_owen/#description","text":"Randomize a point set with integer coordinates using Owen\u2019s scrambling.","title":"Description"},{"location":"scrambling_owen/#license","text":"BSD, see ScramblingOwen.hpp","title":"License"},{"location":"scrambling_owen/#execution","text":"Parameters: [HELP] -i [string] Input file -o [string=output_pts.dat] Output file --silent Silent mode -h Displays this help message To generate a 2D point set of 1024 samples with a whitenoise distribution, we can use the following client line command: ./src/scrambling/CranleyPatterson_2dd -i pointset.edat -o scrambledset.edat Or one can use the following C++ code: ScramblingOwen scrambler ; Pointset < D , T , P > pts ; Pointset < D , T , P > pts_scrambled ; //we assume pts is filled scrambler . scramble < D , T , P > ( pts , pts_scrambled ); PointsetWriter < D , T , P > writer ; writer . open ( \"scrambledset.edat\" ); writer . writePointset ( pts_scrambled ); writer . close ();","title":"Execution"},{"location":"scrambling_owen/#results","text":"./src/scrambling/DigitalXOR_2di -i sobol_m3_1024.edat -o scrambled.edat Input sobol_m3_1024.edat Output scrambled_m3.edat","title":"Results"},{"location":"scripts_discrepancy_graph/","text":"Discrepancy graph Files src/scripts/generate_discrepancy_graph_onfly.sh Description This test executes a given sampler and discrepancy test to generate a graph of discrepancy. This tests outputs the discrepancy data, but it can also output a png graph using gnuplot. Note that the generated graph also plots the theoretical 2D star discrepancy for low discrepancy samplers and a pure random sampler. If plotting discrepancy for higher dimensional samplers or using a discrepancy different than the l_inf star discrepancy, those references won\u2019t be pertinent. Execution Parameters: [Help] -s | --sampler the sampler executable WILL BE RUN AS ./sampler_exe -o [ouput file] -n [nb_points] -d | --discrepancer the executable computing the discrepancy WILL BE RUN AS ./discrepancy_exe -i [input pointset] -o [ouput file] --min the min value of the resulting graph --max the max value of the resulting graph --step the step between tho points of the graph (regular stepping) --log if set, the min value will be 2^min, the max 2^max and the step 2^step --silent set the script to silent mode --gnuplot if set, gnuplot will be called to generate a simple plot of the final graph --sort if set, the resulting graph will be sorted automatically --sname sets the sampler name. If not given, this name will be deduced from the sampler executable Results ../src/scripts/generate_discrepancy_graph_onfly.sh -s \"./src/samplers/Whitenoise_2dd\" -d \"./src/discrepancy/StarDiscrepancy_fromfile_2dd\" --min 4 --max 8 --step 0.5 --log --sort --gnuplot File Whitenoise_2dd_discrepancy_graph_StarDiscrepancy_fromfile_2dd_3671.dat Graph ../src/scripts/generate_discrepancy_graph_onfly.sh -s \"./src/samplers/Sobol_2dd -d ../data/sobol/new-joe-kuo-6.21201\" -d \"./src/discrepancy/GeneralizedL2Discrepancy_fromfile_2dd\" --min 4 --max 16 --step 0.125 --log --sort --gnuplot --sname Sobol File Sobol_discrepancy_graph_GeneralizedL2Discrepancy_fromfile_2dd_16456.dat Graph ../src/scripts/generate_discrepancy_graph_onfly.sh -s \"./src/samplers/Stratified_4dd\" -d \"./src/discrepancy/GeneralizedL2Discrepancy_fromfile_4dd\" --min 6 --max 18 --step 1 --log --sort --gnuplot File Stratified_4dd_discrepancy_graph_GeneralizedL2Discrepancy_fromfile_4dd_24898.dat Graph","title":"Script discrepancy"},{"location":"scripts_discrepancy_graph/#discrepancy-graph","text":"","title":"Discrepancy graph"},{"location":"scripts_discrepancy_graph/#files","text":"src/scripts/generate_discrepancy_graph_onfly.sh","title":"Files"},{"location":"scripts_discrepancy_graph/#description","text":"This test executes a given sampler and discrepancy test to generate a graph of discrepancy. This tests outputs the discrepancy data, but it can also output a png graph using gnuplot. Note that the generated graph also plots the theoretical 2D star discrepancy for low discrepancy samplers and a pure random sampler. If plotting discrepancy for higher dimensional samplers or using a discrepancy different than the l_inf star discrepancy, those references won\u2019t be pertinent.","title":"Description"},{"location":"scripts_discrepancy_graph/#execution","text":"Parameters: [Help] -s | --sampler the sampler executable WILL BE RUN AS ./sampler_exe -o [ouput file] -n [nb_points] -d | --discrepancer the executable computing the discrepancy WILL BE RUN AS ./discrepancy_exe -i [input pointset] -o [ouput file] --min the min value of the resulting graph --max the max value of the resulting graph --step the step between tho points of the graph (regular stepping) --log if set, the min value will be 2^min, the max 2^max and the step 2^step --silent set the script to silent mode --gnuplot if set, gnuplot will be called to generate a simple plot of the final graph --sort if set, the resulting graph will be sorted automatically --sname sets the sampler name. If not given, this name will be deduced from the sampler executable","title":"Execution"},{"location":"scripts_discrepancy_graph/#results","text":"../src/scripts/generate_discrepancy_graph_onfly.sh -s \"./src/samplers/Whitenoise_2dd\" -d \"./src/discrepancy/StarDiscrepancy_fromfile_2dd\" --min 4 --max 8 --step 0.5 --log --sort --gnuplot File Whitenoise_2dd_discrepancy_graph_StarDiscrepancy_fromfile_2dd_3671.dat Graph ../src/scripts/generate_discrepancy_graph_onfly.sh -s \"./src/samplers/Sobol_2dd -d ../data/sobol/new-joe-kuo-6.21201\" -d \"./src/discrepancy/GeneralizedL2Discrepancy_fromfile_2dd\" --min 4 --max 16 --step 0.125 --log --sort --gnuplot --sname Sobol File Sobol_discrepancy_graph_GeneralizedL2Discrepancy_fromfile_2dd_16456.dat Graph ../src/scripts/generate_discrepancy_graph_onfly.sh -s \"./src/samplers/Stratified_4dd\" -d \"./src/discrepancy/GeneralizedL2Discrepancy_fromfile_4dd\" --min 6 --max 18 --step 1 --log --sort --gnuplot File Stratified_4dd_discrepancy_graph_GeneralizedL2Discrepancy_fromfile_4dd_24898.dat Graph","title":"Results"},{"location":"scripts_integration_graph/","text":"Integration graph Files src/scripts/generate_integration_graph_onfly.sh Description This test executes a given sampler and integration test to generate a graph of variance and MSE in integration. This tests outputs the integration data, but it can also output a png graph using gnuplot. Note that the generated graph also plots the theoretical worst case 2D variance in integration for low discrepancy samplers and a pure random sampler. If plotting integration for higher dimensional samplers or for specific integrands, those references won\u2019t be pertinent. Execution Parameters: [Help] -s | --sampler the sampler executable WILL BE RUN AS ./sampler_exe -o [ouput file] -n [nb_points] -i | --integrator the executable computing the integration WILL BE RUN AS ./integration_exe -i [input pointset] -o [ouput file] --min the min value of the resulting graph --max the max value of the resulting graph --step the step between tho points of the graph (regular stepping) --log if set, the min value will be 2^min, the max 2^max and the step 2^step --silent set the script to silent mode --rewrite if set, if a graph with the same name already exitsts, the results will be appened to it --gnuplot if set, gnuplot will be called to generate a simple plot of the final graph --sort if set, the resulting graph will be sorted automatically --sname sets the sampler name. If not given, this name will be deduced from the sampler executable Results ../src/scripts/generate_integration_graph_onfly.sh -s \"./src/samplers/Whitenoise_2dd -m 100\" -i \"./src/integration/IntegrationNSphere_fromfile_2dd\" --min 4 --max 18 --gnuplot --sort --step 0.5 File pointsets_Whitenoise_2dd-m100_integration_graph_IntegrationNSphere_fromfile_2dd_11356.dat Graph MSE Graph Variance ../src/scripts/generate_integration_graph_onfly.sh -s \"./src/samplers/SobolIndices_2dd\" -i \"./src/integration/IntegrationImage2D_fromfile_2dd --image ../data/HDR/HDRimage1600x1600_000.exr\" --min 4 --max 18 --gnuplot --sort --step 0.25 File pointsets_SobolIndices_2dd_integration_graph_HDRimage1600x1600_000.exr_4342.dat Graph MSE ../src/scripts/generate_integration_graph_onfly.sh -s \"./src/samplers/Stratified_4dd -m 20\" -i \"./src/integration/IntegrationNSphere_fromfile_4dd\" --min 4 --max 18 --gnuplot --sort --step 0.25 File pointsets_Stratified_4dd-m20_integration_graph_IntegrationNSphere_fromfile_4dd_4405.dat Graph MSE Graph Variance","title":"Script integration"},{"location":"scripts_integration_graph/#integration-graph","text":"","title":"Integration graph"},{"location":"scripts_integration_graph/#files","text":"src/scripts/generate_integration_graph_onfly.sh","title":"Files"},{"location":"scripts_integration_graph/#description","text":"This test executes a given sampler and integration test to generate a graph of variance and MSE in integration. This tests outputs the integration data, but it can also output a png graph using gnuplot. Note that the generated graph also plots the theoretical worst case 2D variance in integration for low discrepancy samplers and a pure random sampler. If plotting integration for higher dimensional samplers or for specific integrands, those references won\u2019t be pertinent.","title":"Description"},{"location":"scripts_integration_graph/#execution","text":"Parameters: [Help] -s | --sampler the sampler executable WILL BE RUN AS ./sampler_exe -o [ouput file] -n [nb_points] -i | --integrator the executable computing the integration WILL BE RUN AS ./integration_exe -i [input pointset] -o [ouput file] --min the min value of the resulting graph --max the max value of the resulting graph --step the step between tho points of the graph (regular stepping) --log if set, the min value will be 2^min, the max 2^max and the step 2^step --silent set the script to silent mode --rewrite if set, if a graph with the same name already exitsts, the results will be appened to it --gnuplot if set, gnuplot will be called to generate a simple plot of the final graph --sort if set, the resulting graph will be sorted automatically --sname sets the sampler name. If not given, this name will be deduced from the sampler executable","title":"Execution"},{"location":"scripts_integration_graph/#results","text":"../src/scripts/generate_integration_graph_onfly.sh -s \"./src/samplers/Whitenoise_2dd -m 100\" -i \"./src/integration/IntegrationNSphere_fromfile_2dd\" --min 4 --max 18 --gnuplot --sort --step 0.5 File pointsets_Whitenoise_2dd-m100_integration_graph_IntegrationNSphere_fromfile_2dd_11356.dat Graph MSE Graph Variance ../src/scripts/generate_integration_graph_onfly.sh -s \"./src/samplers/SobolIndices_2dd\" -i \"./src/integration/IntegrationImage2D_fromfile_2dd --image ../data/HDR/HDRimage1600x1600_000.exr\" --min 4 --max 18 --gnuplot --sort --step 0.25 File pointsets_SobolIndices_2dd_integration_graph_HDRimage1600x1600_000.exr_4342.dat Graph MSE ../src/scripts/generate_integration_graph_onfly.sh -s \"./src/samplers/Stratified_4dd -m 20\" -i \"./src/integration/IntegrationNSphere_fromfile_4dd\" --min 4 --max 18 --gnuplot --sort --step 0.25 File pointsets_Stratified_4dd-m20_integration_graph_IntegrationNSphere_fromfile_4dd_4405.dat Graph MSE Graph Variance","title":"Results"},{"location":"scripts_plot_pcf/","text":"Plot PCF Files src/scripts/plot_PCF.sh Description Return a .pdf plot of a PCF histogram. Execution ../src/scripts/plot_PCF.sh < input_pcf_dat_file > < output_pdf_file > Results ../src/scripts/plot_PCF.sh pcf.dat pcf.pdf File pcf.dat Graph","title":"Plot PCF"},{"location":"scripts_plot_pcf/#plot-pcf","text":"","title":"Plot PCF"},{"location":"scripts_plot_pcf/#files","text":"src/scripts/plot_PCF.sh","title":"Files"},{"location":"scripts_plot_pcf/#description","text":"Return a .pdf plot of a PCF histogram.","title":"Description"},{"location":"scripts_plot_pcf/#execution","text":"../src/scripts/plot_PCF.sh < input_pcf_dat_file > < output_pdf_file >","title":"Execution"},{"location":"scripts_plot_pcf/#results","text":"../src/scripts/plot_PCF.sh pcf.dat pcf.pdf File pcf.dat Graph","title":"Results"},{"location":"scripts_plot_radial/","text":"Plot Radial Power Spectrum Files src/scripts/plot_radial_spectrum.sh Description Return a .pdf plot of a radial spectrum histogram. Execution ../src/scripts/plot_radial_spectrum.sh < input_radial_dat_file > < output_pdf_file > Results ../src/scripts/plot_radial_spectrum.sh radial.dat radial.pdf File radial.dat Graph","title":"Plot Radial"},{"location":"scripts_plot_radial/#plot-radial-power-spectrum","text":"","title":"Plot Radial Power Spectrum"},{"location":"scripts_plot_radial/#files","text":"src/scripts/plot_radial_spectrum.sh","title":"Files"},{"location":"scripts_plot_radial/#description","text":"Return a .pdf plot of a radial spectrum histogram.","title":"Description"},{"location":"scripts_plot_radial/#execution","text":"../src/scripts/plot_radial_spectrum.sh < input_radial_dat_file > < output_pdf_file >","title":"Execution"},{"location":"scripts_plot_radial/#results","text":"../src/scripts/plot_radial_spectrum.sh radial.dat radial.pdf File radial.dat Graph","title":"Results"},{"location":"spectral_fourier/","text":"Fourier Analysis Files src/spectral/Fourier2D.hpp src/spectral/Fourier_2dd.cpp Description Computes the Fourier power spectrum of the input point set (Discrete Fourier Transform). Can return a .png of the Fourier power spectrum, a .dat of the Fourier power spectrum, a .dat opf the Fourier spectrum, and/or a .dat of the radial average of this spectrum. The radial average can then be plotted using the following script . This executable relies on the FFTW library. Note This tool requires FFTW library. You would also need to set cmake .. -DUSE_FFTW=true when generating the project. License BSD, see Fourier2D.hpp Execution Parameters: [HELP] -h Display this help message -i [string] The input pointset --domain [double=4] The fourier domain ( D*sqrt(N) ) --Fdat [string] The file to write the fourier spectrum --Pdat [string] The file to write the power spectrum --Rdat [string] The file to write the radial spectrum --radial-nbbins [uint=200] The number of bins in the radial hitogram. -P [string] The image to draw the power spectrum --limit-size If set, the discretization will be limited onto 4096^2. This allows to compute the Fourier spectrum of big pointsets but changes the domain --log-bins If set, the radial bins size will increase logarithmically To generate the fourier spectrum of a given point set, we can use the following client line command: ./src/spectral/Fourier_2dd -i penrose4096.dat -P fourier.png Or one can use the following C++ code: bool param_limit_size = false ; double domain = 4.0 ; uint param_radial_nbbins = 200 ; Fourier2D fourier ; fourier . setDomain ( domain ); fourier . setNbBinsRadial ( param_radial_nbbins ); Pointset < D , double , Point > pts ; fourier . compute < 2 , double , Point < 2 , double > > ( pts , param_limit_size ); HistogramWriter < 2 , double , double > writer ; writer . open ( \"spectrum.dat\" ); writer . writeHistogram ( fourier . spectrum_data ); writer . close (); writer . open ( \"power.dat\" ); writer . writeHistogram ( fourier . power_spectrum_data ); writer . close (); writer . open ( \"radial.dat\" ); writer . writeHistogram ( fourier . radial_data ); writer . close (); Results ./src/spectral/Fourier_2dd -i penrose4096.dat -P fourier.png --Rdat radial.dat File penrose4096.dat Fourier Radial radial.dat ./src/spectral/Fourier_2dd -i penrose4096.dat -P fourier_domain2.png --Rdat radial_domain2.dat --domain 2 File penrose4096.dat Fourier Radial radial_domain2.dat ./src/spectral/Fourier_2dd -i penrose4096.dat -P fourier_log.png --Rdat radial_log.dat --log-bins File penrose4096.dat Fourier Radial radial_log.dat","title":"Spectral Analysis"},{"location":"spectral_fourier/#fourier-analysis","text":"","title":"Fourier Analysis"},{"location":"spectral_fourier/#files","text":"src/spectral/Fourier2D.hpp src/spectral/Fourier_2dd.cpp","title":"Files"},{"location":"spectral_fourier/#description","text":"Computes the Fourier power spectrum of the input point set (Discrete Fourier Transform). Can return a .png of the Fourier power spectrum, a .dat of the Fourier power spectrum, a .dat opf the Fourier spectrum, and/or a .dat of the radial average of this spectrum. The radial average can then be plotted using the following script . This executable relies on the FFTW library. Note This tool requires FFTW library. You would also need to set cmake .. -DUSE_FFTW=true when generating the project.","title":"Description"},{"location":"spectral_fourier/#license","text":"BSD, see Fourier2D.hpp","title":"License"},{"location":"spectral_fourier/#execution","text":"Parameters: [HELP] -h Display this help message -i [string] The input pointset --domain [double=4] The fourier domain ( D*sqrt(N) ) --Fdat [string] The file to write the fourier spectrum --Pdat [string] The file to write the power spectrum --Rdat [string] The file to write the radial spectrum --radial-nbbins [uint=200] The number of bins in the radial hitogram. -P [string] The image to draw the power spectrum --limit-size If set, the discretization will be limited onto 4096^2. This allows to compute the Fourier spectrum of big pointsets but changes the domain --log-bins If set, the radial bins size will increase logarithmically To generate the fourier spectrum of a given point set, we can use the following client line command: ./src/spectral/Fourier_2dd -i penrose4096.dat -P fourier.png Or one can use the following C++ code: bool param_limit_size = false ; double domain = 4.0 ; uint param_radial_nbbins = 200 ; Fourier2D fourier ; fourier . setDomain ( domain ); fourier . setNbBinsRadial ( param_radial_nbbins ); Pointset < D , double , Point > pts ; fourier . compute < 2 , double , Point < 2 , double > > ( pts , param_limit_size ); HistogramWriter < 2 , double , double > writer ; writer . open ( \"spectrum.dat\" ); writer . writeHistogram ( fourier . spectrum_data ); writer . close (); writer . open ( \"power.dat\" ); writer . writeHistogram ( fourier . power_spectrum_data ); writer . close (); writer . open ( \"radial.dat\" ); writer . writeHistogram ( fourier . radial_data ); writer . close ();","title":"Execution"},{"location":"spectral_fourier/#results","text":"./src/spectral/Fourier_2dd -i penrose4096.dat -P fourier.png --Rdat radial.dat File penrose4096.dat Fourier Radial radial.dat ./src/spectral/Fourier_2dd -i penrose4096.dat -P fourier_domain2.png --Rdat radial_domain2.dat --domain 2 File penrose4096.dat Fourier Radial radial_domain2.dat ./src/spectral/Fourier_2dd -i penrose4096.dat -P fourier_log.png --Rdat radial_log.dat --log-bins File penrose4096.dat Fourier Radial radial_log.dat","title":"Results"},{"location":"stats_PCF/","text":"Point Correlation Function Files src/bin/statistics/computePCF_2dd.cpp src/statistics/PCF.hpp Description The Pair Correlation Function expresses the distribution of distances between pairs of points in a point set. Intuitively, it expresses the number of samples that are at a distance r from a \u201ctypical\u201d sample. Oztireli devised a simplified estimator for this measure in the particular case of isotropic and stationary point processes. It\u2019s this function that is implemented here. Execution Parameters: [HELP] --silent Silent mode -h Displays this help message -i the input pointset -o the output PCF --rmin the minimum radius --rmax the maximal radius --sigma the sigma of the gaussian used for smoothing --nbbins the number of histogram bins --unnorm-dist does not normalize the distances in the PCF When computing a PCF on a normalized pointset, the normalization is done dividing the distances by R, R being the maximal packing density of 2D spheres ( http://mathworld.wolfram.com/HyperspherePacking.html ). If normalization is active, rmin and rmax are normalized too, this means that the values given as parameters for rmin and rmax are not considered normalized . To compute the PCF of a 2D pointset, we can use the following client line command: ./bin/statistics/computePCF_2dd -i toto.dat -o pcf.dat Or the following C++ code: PCF pcf_engine ; Pointset < 2 , double , Point < 2 , double > > pts ; //we assume pts is filled Histogram1dd pcf_data ; bool normalize = true ; double R = 2.0 * sqrt ( 1.0 / ( 2.0 * sqrt ( 3.0 ) * pts . size ()) ); double smoothing = 0.1 * d ; //To start as close as possible from 0 without introducing smoothing artefacts double rmin = 1.5 * smoothing ; //Default value assume normalization as we do not know the unnormalized distances between samples double rmax = 2.5 * d ; pcf_engine . compute < 2 , double , Point < 2 , double > > ( pts , pcf_data , rmin , rmax , nbbins , smoothing , normalize ); Note that this code only works for 2D point sets. Results From the following pointset bnot_1024.dat -> Normalized and Unnormalized Data ./bin/statistics/computePCF_2dd -i bnot_1024.dat -o pcf.dat ./bin/statistics/computePCF_2dd -i bnot_1024.dat -o pcf.dat --unnorm-dist -> Changing the rmin, rmax parameters ./bin/statistics/computePCF_2dd -i bnot_1024.dat -o pcf.dat --rmin 0.03 --rmax 0.06 --unnorm-dist ./bin/statistics/computePCF_2dd -i bnot_1024.dat -o pcf.dat --rmin 0.03 --rmax 0.06 -> Changing smoothness, note that as sigma changes, so does the Y axis ./bin/statistics/computePCF_2dd -i bnot_1024.dat -o pcf.dat --sigma 0.001 ./bin/statistics/computePCF_2dd -i bnot_1024.dat -o pcf.dat --sigma 0.3","title":"Pair Correlation Function"},{"location":"stats_PCF/#point-correlation-function","text":"","title":"Point Correlation Function"},{"location":"stats_PCF/#files","text":"src/bin/statistics/computePCF_2dd.cpp src/statistics/PCF.hpp","title":"Files"},{"location":"stats_PCF/#description","text":"The Pair Correlation Function expresses the distribution of distances between pairs of points in a point set. Intuitively, it expresses the number of samples that are at a distance r from a \u201ctypical\u201d sample. Oztireli devised a simplified estimator for this measure in the particular case of isotropic and stationary point processes. It\u2019s this function that is implemented here.","title":"Description"},{"location":"stats_PCF/#execution","text":"Parameters: [HELP] --silent Silent mode -h Displays this help message -i the input pointset -o the output PCF --rmin the minimum radius --rmax the maximal radius --sigma the sigma of the gaussian used for smoothing --nbbins the number of histogram bins --unnorm-dist does not normalize the distances in the PCF When computing a PCF on a normalized pointset, the normalization is done dividing the distances by R, R being the maximal packing density of 2D spheres ( http://mathworld.wolfram.com/HyperspherePacking.html ). If normalization is active, rmin and rmax are normalized too, this means that the values given as parameters for rmin and rmax are not considered normalized . To compute the PCF of a 2D pointset, we can use the following client line command: ./bin/statistics/computePCF_2dd -i toto.dat -o pcf.dat Or the following C++ code: PCF pcf_engine ; Pointset < 2 , double , Point < 2 , double > > pts ; //we assume pts is filled Histogram1dd pcf_data ; bool normalize = true ; double R = 2.0 * sqrt ( 1.0 / ( 2.0 * sqrt ( 3.0 ) * pts . size ()) ); double smoothing = 0.1 * d ; //To start as close as possible from 0 without introducing smoothing artefacts double rmin = 1.5 * smoothing ; //Default value assume normalization as we do not know the unnormalized distances between samples double rmax = 2.5 * d ; pcf_engine . compute < 2 , double , Point < 2 , double > > ( pts , pcf_data , rmin , rmax , nbbins , smoothing , normalize ); Note that this code only works for 2D point sets.","title":"Execution"},{"location":"stats_PCF/#results","text":"From the following pointset bnot_1024.dat -> Normalized and Unnormalized Data ./bin/statistics/computePCF_2dd -i bnot_1024.dat -o pcf.dat ./bin/statistics/computePCF_2dd -i bnot_1024.dat -o pcf.dat --unnorm-dist -> Changing the rmin, rmax parameters ./bin/statistics/computePCF_2dd -i bnot_1024.dat -o pcf.dat --rmin 0.03 --rmax 0.06 --unnorm-dist ./bin/statistics/computePCF_2dd -i bnot_1024.dat -o pcf.dat --rmin 0.03 --rmax 0.06 -> Changing smoothness, note that as sigma changes, so does the Y axis ./bin/statistics/computePCF_2dd -i bnot_1024.dat -o pcf.dat --sigma 0.001 ./bin/statistics/computePCF_2dd -i bnot_1024.dat -o pcf.dat --sigma 0.3","title":"Results"},{"location":"stats_minDist/","text":"Minimal Distance Files src/bin/statistics/computeMinDist_2dd.cpp src/statistics/MinimalDistance.hpp Description The minimal distance between samples is computed by taking all distances between pairs of samples and keeping the minimum. Maximizing this distance can be a way to improve the quality of a point set. License BSD, see source codes. Execution Parameters: [HELP] --silent Silent mode -h Displays this help message -i the input pointset --non-toric does not compute toric distances Note that by default the program computes the toric minimal distance between 2D samples. The minimal distance is a measure that is only valid when performed over several realisations of a sampler. Hence, the executable returns a variance, minimal, maximal and average of all minimal distances of all point sets is the input file. To compute the minimal distance from a file containing one or several 2D point sets, we can use the following client line command: ./bin/statistics/computeMinDist_2dd -i toto.dat Or to compute the min distance of a single point set, one can use the following C++ code: MinimalDistance md_engine ; Pointset < 2 , double , Point < 2 , double > > pts ; bool toric = true ; //we assume pts is filled double mindist ; md_engine . compute < 2 , double , Point < 2 , double > > ( pts , toric , mindist ); Results From 10 realisations of the random sampler whitenoise_m10_256.dat ./bin/statistics/computeMinDist_2dd -i whitenoise_m10_256.dat #Samples #Avg MinDist #Var MinDist #Max MinDist #Min MinDist 256 0.00348864 1.39075e-06 0.00514913 0.00122 ./bin/statistics/computeMinDist_2dd -i whitenoise_m10_256.dat --non-toric #Samples #Avg MinDist #Var MinDist #Max MinDist #Min MinDist 256 0.00351797 1.5076e-06 0.00544248 0.00122 From a single realisations of the Sobol sequence, with integer samples sobol_256.edat Note that in this case, we have to use a .edat file to store our samples, otherwise the size of the domain is unknown and therefore we cannot provide toric distances. ./bin/statistics/computeMinDist_2dd -i sobol_256.edat #Samples #Avg MinDist #Var MinDist #Max MinDist #Min MinDist 256 1.41421 0 1.41421 1.41421","title":"Minimum Distance"},{"location":"stats_minDist/#minimal-distance","text":"","title":"Minimal Distance"},{"location":"stats_minDist/#files","text":"src/bin/statistics/computeMinDist_2dd.cpp src/statistics/MinimalDistance.hpp","title":"Files"},{"location":"stats_minDist/#description","text":"The minimal distance between samples is computed by taking all distances between pairs of samples and keeping the minimum. Maximizing this distance can be a way to improve the quality of a point set.","title":"Description"},{"location":"stats_minDist/#license","text":"BSD, see source codes.","title":"License"},{"location":"stats_minDist/#execution","text":"Parameters: [HELP] --silent Silent mode -h Displays this help message -i the input pointset --non-toric does not compute toric distances Note that by default the program computes the toric minimal distance between 2D samples. The minimal distance is a measure that is only valid when performed over several realisations of a sampler. Hence, the executable returns a variance, minimal, maximal and average of all minimal distances of all point sets is the input file. To compute the minimal distance from a file containing one or several 2D point sets, we can use the following client line command: ./bin/statistics/computeMinDist_2dd -i toto.dat Or to compute the min distance of a single point set, one can use the following C++ code: MinimalDistance md_engine ; Pointset < 2 , double , Point < 2 , double > > pts ; bool toric = true ; //we assume pts is filled double mindist ; md_engine . compute < 2 , double , Point < 2 , double > > ( pts , toric , mindist );","title":"Execution"},{"location":"stats_minDist/#results","text":"From 10 realisations of the random sampler whitenoise_m10_256.dat ./bin/statistics/computeMinDist_2dd -i whitenoise_m10_256.dat #Samples #Avg MinDist #Var MinDist #Max MinDist #Min MinDist 256 0.00348864 1.39075e-06 0.00514913 0.00122 ./bin/statistics/computeMinDist_2dd -i whitenoise_m10_256.dat --non-toric #Samples #Avg MinDist #Var MinDist #Max MinDist #Min MinDist 256 0.00351797 1.5076e-06 0.00544248 0.00122 From a single realisations of the Sobol sequence, with integer samples sobol_256.edat Note that in this case, we have to use a .edat file to store our samples, otherwise the size of the domain is unknown and therefore we cannot provide toric distances. ./bin/statistics/computeMinDist_2dd -i sobol_256.edat #Samples #Avg MinDist #Var MinDist #Max MinDist #Min MinDist 256 1.41421 0 1.41421 1.41421","title":"Results"},{"location":"utils_draw_pointset/","text":"Draw Pointset Files src/bin/utils/draw_fromfile_2dd.cpp Description An executable that returns a illustration of a 2D input pointset. Execution Parameters: [HELP] -i [string] The input pointset -o [string] The output image -h Displays this help message --radius [0< double <1 =0.0025] The point radius --tiled display 3x3 tiling of the point set --numbering Numbered samples --fontsize [int=10] Font size --offset [0 <= int < 0.5 =0] Border size --border Numbered samples Note the input pointset should be either a 2D pointset defined in the domain [0,1], or a 2D pointset with a ebin or edat format. To draw a pointset one can use the following client line command ./bin/utils/draw_fromfile_2dd -i pointset_file.dat -o pointset_draw.ps Or the following C++ code: double radius = 0.0025 ; bool tiled = false ; bool numbering = false ; bool drawborder = false ; double offsetsize = 0 ; int fontsize = 10 ; Pointset < 2 , double , Point < 2 , double > > pts ; PointsetReader < 2 , double , Point < 2 , double > > pts_reader ; pts_reader . open ( \"pointset_file.dat\" ); pts_reader . readPointset ( pts ); pts_reader . close (); PointsetIllustrator < 2 , double , Point < 2 , double > > illu ; illu . setBorderSize ( offsetsize ); illu . setNumbered ( numbering ); illu . setFontSize ( fontsize ); illu . setTiled ( tiled ); illu . setPointRadius ( radius ); illu . open ( \"pointset_draw.ps\" ); illu . setColor ( 0 , 0 , 0 ); if ( drawborder ) illu . drawRectangle ( offsetsize , offsetsize , 1-2 * offsetsize , 1-2 * offsetsize , 0.0025 ); illu . drawPointset ( pts ); illu . close (); Results ./bin/utils/draw_fromfile_2dd -i penrose1024.dat -o pointset_rad001.ps --radius 0.01 Input Pointset penrose1024.dat Output image .PS File pointset_rad001.ps ./bin/utils/draw_fromfile_2dd -i penrose1024.dat -o pointset_rad0005.ps --radius 0.01 Input Pointset penrose1024.dat Output image .PS File pointset_rad0005.ps ./bin/utils/draw_fromfile_2dd -i penrose1024.dat -o pointset_tiled.ps --tiled Input Pointset penrose1024.dat Output image .PS File pointset_tiled.ps ./bin/utils/draw_fromfile_2dd -i penrose1024.dat -o pointset_offset.ps --offset 0.1 Input Pointset penrose1024.dat Output image .PS File pointset_offset.ps ./bin/utils/draw_fromfile_2dd -i penrose1024.dat -o pointset_offsetborder.ps --border 0.02 --offset 0.1 Input Pointset penrose1024.dat Output image .PS File pointset_offsetborder.ps ./bin/utils/draw_fromfile_2dd -i penrose25.dat -o pointset_nb.ps --numbering --radius 0.01 Input Pointset penrose25.dat Output image .PS File pointset_nb.ps ./bin/utils/draw_fromfile_2dd -i penrose25.dat -o pointset_nb_font.ps --numbering --radius 0.01 --fontsize 15 Input Pointset penrose25.dat Output image .PS File pointset_nb_font.ps","title":"Plot pointset"},{"location":"utils_draw_pointset/#draw-pointset","text":"","title":"Draw Pointset"},{"location":"utils_draw_pointset/#files","text":"src/bin/utils/draw_fromfile_2dd.cpp","title":"Files"},{"location":"utils_draw_pointset/#description","text":"An executable that returns a illustration of a 2D input pointset.","title":"Description"},{"location":"utils_draw_pointset/#execution","text":"Parameters: [HELP] -i [string] The input pointset -o [string] The output image -h Displays this help message --radius [0< double <1 =0.0025] The point radius --tiled display 3x3 tiling of the point set --numbering Numbered samples --fontsize [int=10] Font size --offset [0 <= int < 0.5 =0] Border size --border Numbered samples Note the input pointset should be either a 2D pointset defined in the domain [0,1], or a 2D pointset with a ebin or edat format. To draw a pointset one can use the following client line command ./bin/utils/draw_fromfile_2dd -i pointset_file.dat -o pointset_draw.ps Or the following C++ code: double radius = 0.0025 ; bool tiled = false ; bool numbering = false ; bool drawborder = false ; double offsetsize = 0 ; int fontsize = 10 ; Pointset < 2 , double , Point < 2 , double > > pts ; PointsetReader < 2 , double , Point < 2 , double > > pts_reader ; pts_reader . open ( \"pointset_file.dat\" ); pts_reader . readPointset ( pts ); pts_reader . close (); PointsetIllustrator < 2 , double , Point < 2 , double > > illu ; illu . setBorderSize ( offsetsize ); illu . setNumbered ( numbering ); illu . setFontSize ( fontsize ); illu . setTiled ( tiled ); illu . setPointRadius ( radius ); illu . open ( \"pointset_draw.ps\" ); illu . setColor ( 0 , 0 , 0 ); if ( drawborder ) illu . drawRectangle ( offsetsize , offsetsize , 1-2 * offsetsize , 1-2 * offsetsize , 0.0025 ); illu . drawPointset ( pts ); illu . close ();","title":"Execution"},{"location":"utils_draw_pointset/#results","text":"./bin/utils/draw_fromfile_2dd -i penrose1024.dat -o pointset_rad001.ps --radius 0.01 Input Pointset penrose1024.dat Output image .PS File pointset_rad001.ps ./bin/utils/draw_fromfile_2dd -i penrose1024.dat -o pointset_rad0005.ps --radius 0.01 Input Pointset penrose1024.dat Output image .PS File pointset_rad0005.ps ./bin/utils/draw_fromfile_2dd -i penrose1024.dat -o pointset_tiled.ps --tiled Input Pointset penrose1024.dat Output image .PS File pointset_tiled.ps ./bin/utils/draw_fromfile_2dd -i penrose1024.dat -o pointset_offset.ps --offset 0.1 Input Pointset penrose1024.dat Output image .PS File pointset_offset.ps ./bin/utils/draw_fromfile_2dd -i penrose1024.dat -o pointset_offsetborder.ps --border 0.02 --offset 0.1 Input Pointset penrose1024.dat Output image .PS File pointset_offsetborder.ps ./bin/utils/draw_fromfile_2dd -i penrose25.dat -o pointset_nb.ps --numbering --radius 0.01 Input Pointset penrose25.dat Output image .PS File pointset_nb.ps ./bin/utils/draw_fromfile_2dd -i penrose25.dat -o pointset_nb_font.ps --numbering --radius 0.01 --fontsize 15 Input Pointset penrose25.dat Output image .PS File pointset_nb_font.ps","title":"Results"},{"location":"utils_histogram_compare/","text":"Histogram Compare Files src/bin/utils/histogram_compare_2dd.cpp Description An executable that returns the maximal distance (Linf distance) and the sum of squared distances (L2 distance) between two 2D histograms. Execution Parameters: [HELP] --h1 Histogram 1 --h2 Histogram 2 Note that the comparison between histograms can only be performed if both histograms contain the same number of bins, with the same x coordinates. To compute the difference between 2 histograms, we can use the following client line command: ./bin/utils/histogram_compare_2dd --h1 pcf.dat --h2 pcf2.dat Or the following C++ code: Histogram1dd histo1 ; Histogram1dd histo2 ; //we assume histograms are filled double l2 , linf ; histo1 . Linf ( histo2 , linf ); histo1 . L2 ( histo2 , l2 ); ``` ## Results For the following histogram , representing PCFs : ! []( data / histo_cmp / pcfs . png ) ./bin/utils/histogram_compare_2dd \u2013h1 pcf.dat \u2013h2 pcf2.dat Distance between Histograms: Linf:0.0884439 L2:0.225963 ```","title":"Histogram compare"},{"location":"utils_histogram_compare/#histogram-compare","text":"","title":"Histogram Compare"},{"location":"utils_histogram_compare/#files","text":"src/bin/utils/histogram_compare_2dd.cpp","title":"Files"},{"location":"utils_histogram_compare/#description","text":"An executable that returns the maximal distance (Linf distance) and the sum of squared distances (L2 distance) between two 2D histograms.","title":"Description"},{"location":"utils_histogram_compare/#execution","text":"Parameters: [HELP] --h1 Histogram 1 --h2 Histogram 2 Note that the comparison between histograms can only be performed if both histograms contain the same number of bins, with the same x coordinates. To compute the difference between 2 histograms, we can use the following client line command: ./bin/utils/histogram_compare_2dd --h1 pcf.dat --h2 pcf2.dat Or the following C++ code: Histogram1dd histo1 ; Histogram1dd histo2 ; //we assume histograms are filled double l2 , linf ; histo1 . Linf ( histo2 , linf ); histo1 . L2 ( histo2 , l2 ); ``` ## Results For the following histogram , representing PCFs : ! []( data / histo_cmp / pcfs . png ) ./bin/utils/histogram_compare_2dd \u2013h1 pcf.dat \u2013h2 pcf2.dat Distance between Histograms: Linf:0.0884439 L2:0.225963 ```","title":"Execution"}]}